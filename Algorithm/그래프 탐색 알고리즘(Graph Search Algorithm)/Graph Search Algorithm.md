# 그래프 탐색 알고리즘

## 너비 우선 검색(Breadth First Search)
가장 단순한 그래프 탐색 알고리즘 중 하나로, 프림(prim)의 **최소 신장 트리 알고리즘**, 다익스트라(Dijkstra)의 **단일 출발점 최단 경로 알고리즘**의 원형이다.

### 탐색 방법
그래프 *G* = (*V*, *E*)에서 **출발점** *s*에 대해 *s*에서 닿을 수 있는 모든 정점을 가지는 **너비 우선 트리**를 만들어 낸다. 너비를 우선한다는 의미는 *s*로부터 거리가 *k* + 1인 한 정점을 만나기 전에 거리가 *k*인 정점을 모두 발견한다는 뜻이다.

탐색의 진행 정도를 따지기 위해 각 정점을 `흰색(WHITE)`에서 `회색(GRAY)`, 마지막으로 `검은색(BLACK)`으로 만든다.
- 흰색: 정점의 초기화 색.
- 회색: 인접한 정점이 흰색일 수도 있는 **경계점**.
- 검은색: 인접한 정점이 모두 탐색된 것을 나타냄.

너비 우선 탐색은 더 이상 탐색할 것이 없는 상태까지 탐색하는데, 이 때 이용하는 것이 **회색 정점으로 이루어진 큐 자료구조**이다.

### 의사 코드(인접 리스트)
``` Swift
BFS(G, s) {
  // 초기화 작업
  for 각각의 정점 u in G.V - {s} {
    u.color = WHITE
    u.d = ∞
    u.π = nil
  }
  s.color = GRAY
  s.d = 0
  s.π = nil
  Queue = ø
  Enqueue(Queue, s)

  // 회색 정점이 사라질 때까지
  // 즉, 모든 점을 탐색할 때까지
  while !Queue.isEmpty() {
    u = Dequeue(Queue)

    // u의 인접 정점을 검사해 흰색 정점을 탐색
    for 각각의 v in G.Adj[u] {
      if v.color == WHITE {
        v.color = GRAY
        v.d = u.d + 1 // 시작점 s로부터의 거리
        v.π = u // 정점 v의 직전 원소 u를 기록
        Enqueue(Queue, v)
      }
    }
    u.color = BLACK
  }
}
```

- 인접 리스트: 모든 정점을 방문하여 그에 인접한 간선들을 조사하므로 시간복잡도는 O(|V| + |E|)라 할 수 있다.
- 인접 행렬: 마찬가지로 모든 정점을 방문하여, 그에 인접한 간선들을 조사하는데, 인접 행렬의 특성 상 모든 간선들을 한 번씩 탐색해야 하므로 결국 O(|V|<sup>2</sup>)라 할 수 있다.

### 최단 경로
정점 *s*에서 정점 *v*로 가는 최단 경로를 구하고 싶을 때 너비 우선 탐색을 사용하면 유용하다. 위의 코드에서 `d(distance)`가 두 정점 간의 최단 경로가 된다.

## 깊이 우선 탐색(Depth First Search)
너비 우선 탐색과 달리 가능한 한 **더 깊이** 파고드는 탐색 방법이다. **재귀**를 사용하는 방식과 **스택**을 이용하는 방식 두 가지가 있다.

### 탐색 방법
쉽게 말해서, 더 탐색할 것이 없을 때까지 나아가고 없다면 다시 원래 자리로 돌아와 다시 탐색을 시작한다.

너비 우선 탐색과 마찬가지로 정점의 상태를 나타내는 `흰색(WHITE)`, `회색(GRAY)`, `검은색(BLACK)`을 칠한다.
- 흰색: 정점의 초기화 색
- 회색: **발견되었을 때**의 색.
- 검은색: 인접 리스트가 **모두 탐색되었을 때**의 색.

색 말고도 깊이 우선 탐색에서는 **시간 기록**을 한다. 각 정점은 처음 발견되었을 때 `v.d`와 인접 리스트의 조사를 마쳤을 때의 `v.f`를 갖는다. 따라서 어떠한 정점 *u*은 시간 `u.d` 전에는 **흰색**, 시간 `u.d`와 `u.f` 사이에는 **회색**, 그 이후에는 **검은색**을 가진다고 할 수 있다.

### 의사 코드
#### 인접 리스트 - 재귀
``` Swift
// 시간을 기록하기 위한 전역 변수
var time = 0

DFS(G) {
  // 초기화 작업
  for 각 정점 u in G.V {
    u.color = WHITE
    u.π = nil
  }

  for 각 정점 u in G.V {
    if u.color == WHITE {
      DFS-VISIT(G, u)
    }
  }
}

DFS-VISIT(G, u) {
  // 흰색 정점 u가 막 발견됨.
  time = time + 1
  u.d = time
  u.color = GRAY

  // 간선 (u, v)를 탐색한다.
  for 각각의 v in G.Adj[u] {
    if v.color == WHITE {
      v.π = u
      DFS-VISIT(G, v)
    }
  }

  // u의 인접 리스트를 모두 탐색 완료.
  u.color = BLACK
  time = time + 1
  u.f = time
}
```

#### 인접리스트 - 스택
``` Swift
var time = 0

DFS(G, s) {
  for 각 정점 u in G.V {
    u.color = WHITE
  }

  Stack = ø
  s.color = GRAY
  Push(Stack, s)
  while !Stack.isEmpty() {
    u = Pop(Stack)
    u.color = BLACK

    for 각각의 정점 v in G.Adj[u] {
      if v.color == WHITE {
        v.color = GRAY
        Push(Stack, v)
      }
    }
  }
}
```

- 인접 리스트: 너비 우선 탐색과 마찬가지로 각 정점을 한 번씩 방문하는데에 O(|V|), 그리고 방문한 정점에 대해서 인접한 간선들을 조사하는 데 총 O(|E|)가 걸리기 때문에 시간복잡도는 O(|V| + |E|)이다.
- 인접 행렬: 역시 개념은 같으나 간선 조사 시 모든 정점으로 가는 간선들을 조사해야 하므로 O(|V<sup>2</sup>|)가 된다.