# 동적 계획법(Dynamic Programming)
동적 계획법은 **분할 정복** 기법과 같이 부분 문제의 해를 결합해 원래 문제의 해를 구하는 방식을 사용한다. 분할 정복은 서로 겹치지 않는 부분 문제로 나누고 그것들을 재귀적으로 해결한 후, 해결한 것들을 다시 결합하여 원래의 문제를 해결한다. 반면, **동적 계획법은 부분 문제가 서로 중복될 때, 즉 부분 문제가 다시 자신의 부분 문제를 공유할 때 적용**할 수 있다. 분할 정복을 통해 이 문제를 해결하면 같은 연산을 반복적으로 하게 되어 필요 이상으로 연산을 하게 된다. 동적 계획법은 반복적인 연산을 피하기 위해 *Memoization(메모)* 기법을 사용하는데, 이는 부분 문제의 결과를 저장해두는 것으로 **메모리를 희생해 시간을 줄이는 것이다**.

즉, 동적 계획법을 적용하는 문제의 특성은 두 가지가 있다.
- 중복되는 부분 문제(Overlapping Subproblem): 부분 문제들이 서로 중복되어 나타는 경우.
- 최적 부분 구조(Optimal Substructure): 부분 구조의 최적해는 결국 최종 최적해의 부분에 해당된다는 말이다.

## 동적 계획법의 단계

일반적으로 **최적화 문제**(**Optimization problem**)에서 동적 계획법을 사용한다. 이런 문제는 다양한 해 중 가장 최적인 해를 찾는 문제이다. 동적 계획법은 다음과 같은 단계를 거쳐 최적해를 구한다.

1. 최적해의 구조적 특징을 찾는다.
2. 최적해의 값을 재귀적으로 정의한다.
3. 최적해의 값을 일반적으로 상향식(bottom-up) 방법으로 계산한다.
4. 계산된 정보들로부터 최적해를 구성한다.

## 하향식 vs. 상향식
동적 계획법 단계 3번의 일반적으로라는 말은 *상향식* 방법이 더 자연스러운 방식이라는 것이다. 가장 동적 계획법의 예인 피보나치 수열을 통해 하향식과 상향식의 차이를 보겠다.

피보나치 수열은 앞의 **두 수의 합이 그 다음 수를 이루는** 수열이다.

동적 계획법의 단계에 따라 이것을 표현해 보겠다(물론 피보나치 수열에서는 최적해란 말은 어울리지 않는다.).
1. 최적해의 구조적 특징을 찾는다.
피보나치 수열의 특징을 찾으면 '두 수의 합이 그 다음 수를 이루는 것'이 구조적 특징이다.
2. 최적해의 값을 재귀적으로 정의한다.
피보나치 수열의 각각의 값도 *피보나치 수열적*으로 표현할 수 있다. 

예를 들어, fib(5)는 다음과 같이 진행된다.
```
fib(5) = fib(3) + fib(4)
       = fib(1) + fib(2) + fib(2) + fib(3)
```
즉, 수열의 각 부분도 다시 같은 특징을 가진 부분 구조로 나눌 수 있고 이것은 재귀적으로 같은 로직을 적용한다는 뜻이 된다. 

그러므로 점화식으로 이를 표현해보면 이러한 식이 나온다.
```
fib(n) = fib(n - 2) + fib(n - 1) (n > 1)
```

3. 최적해의 값을 일반적으로 상향식(bottom-up) 방법으로 계산한다.
여기서는 하향식과 상향식 둘 다 해보겠다.

### 하향식(Top-down)
재귀를 이용하는 방식으로 큰 문제를 풀 때 부분 문제의 결과값이 저장되어 있는 것을 확인하고 있다면 그대로 사용하고 없다면 계산해서 푼다.
``` java
static int[] memoization = new int[100];

static int topDownFib(int n) {
    if (n <= 1) {
        return n;
    } else {
        if (memoization[n] > 0) {
            return memoization[n];
        }
        memoization[n] = fib(n - 2) + fib(n - 1);
        return memoization[n];
    }
}
```

### 상향식(Bottom-up)
반대로 작은 문제부터 풀어나가는 방식으로 큰 문제를 풀 때 작은 문제의 결과값은 반드시 저장이 되어 있다. 그래서 항상 바로 큰 문제를 풀 수 있다. 보통 for 문을 통해 계산한다.
``` java
static int[] memoization = new int[100];

static int bottomUpFib(int n) {
    memoization[0] = 0;
    memoization[1] = 1;

    for (int i = 2; i <= n; i++) {
        memoization[i] = memoization[i - 2] + memoization[i - 1];
    }

    return memoization[n];
}
```
하향식과 상향식 모두 점근적인 시간 복잡도는 같다. 그러나 **상향식 방법이 좀 더 나은 상수 시간을 가지기 때문에 좀 더 빠르다**.

4. 계산된 정보들로부터 최적해를 구성한다.
나온 결과값을 받으면 된다.

### 예제 1: [최장 공통 부분 시퀀스 문제](https://github.com/wnstkdyu/CSStudy/blob/master/CodingTest/%EC%9E%90%EC%A3%BC%20%EB%82%98%EC%98%A4%EB%8A%94%20%EC%A3%BC%EC%A0%9C/%EC%B5%9C%EC%9E%A5%20%EA%B3%B5%ED%86%B5%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4(LCS).md)

### 예제 2: [2 X n 타일링](https://www.acmicpc.net/problem/11726)


