# 삽입 정렬 (Insertion Sort)

**들어가기에 앞서**

- 이 글은 *Matthijs Hollemans* 가 최초 작성하였고, [*Kangsoo Lee*](https://github.com/oaksong) 가 한국어로 번역하였습니다.
- 소스 코드와 예제 프로젝트는 Swift Algorithm Club의 [원 글 저장소](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Insertion%20Sort)에서 확인할 수 있습니다.
- Swift Algorithm Club의 [한국어 번역판 저장소](https://github.com/oaksong/swift-algorithm-club-ko)에서 더 많은 자료를 만나보세요.

---

목표: 배열을 오름차순(또는 내림차순)으로 정렬하기

숫자들로 이루어진 배열을 올바른 순서로 정렬하고자 한다. 삽입 정렬 알고리즘은 다음과 같이 작동된다.

- 숫자들을 정렬되지 않고 차곡차곡 쌓여 있는 더미(pile)로 생각한다.
- 더미에서 숫자 하나를 고른다. 무엇을 고르든 상관없지만 편한 대로 맨 위에 있는 것을 고른다.
- 새로운 배열을 하나 준비하고 고른 숫자를 삽입한다.
- 더미에서 숫자 하나를 다시 고르고 배열에 삽입한다. 첫 번째로 삽입한 숫자의 앞 또는 뒤에 위치할 것인데, 정렬 상태를 유지하도록 하는 위치에 삽입한다.
- 다시 숫자를 하나 고르고 적합한 위치에 삽입한다.
- 더미에 숫자가 남아 있지 않을 때까지 이 과정을 반복한다.

이 알고리즘은 더미에서 숫자를 골라 배열에 삽입한다는 아이디어 때문에 "삽입" 정렬이라 불린다.

## 예시

정렬이 되지 않은 더미 `[ 8, 3, 5, 4, 6 ]`를 오름차순으로 정렬해보자.

첫 번째로 `8`을 골라 새로운 배열에 삽입한다. 배열은 현재 아무것도 없는 상태이므로 그냥 삽입하면 된다.

- 정렬된 배열: `[ 8 ]`
- 더미: `[ 3, 5, 4, 6 ]`

다음 숫자인 `3`을 골라 삽입한다. `8` 앞에 위치해야 한다.

- 정렬된 배열: `[ 3, 8 ]`
- 더미: `[ 5, 4, 6 ]`

다음으로 `5`를 골라 삽입한다. `3`과 `8` 사이에 위치해야 한다.

- 정렬된 배열: `[ 3, 5, 8 ]`
- 더미: `[ 4, 6 ]`

더미가 빌 때까지 이 과정을 반복한다.

## 제자리에서 정렬

지금까지의 설명만 들어보면 두 개의 배열이 필요해 보인다. 정렬되지 않은 더미를 위한 배열 하나와 정렬된 배열 하나.

그런데 배열 하나만 가지고도 *제자리에서(in-place)* 삽입 정렬을 할 수 있다. 정렬된 부분과 그렇지 않은 부분을 잘 구분하기만 하면 된다.

최초에 배열 `[ 8, 3, 5, 4, 6 ]`이 있다고 하자. 정렬된 부분이 끝나는 지점과 정렬되지 않은 더미가 시작하는 지점을 `|`로 구분한다.

```
[| 8, 3, 5, 4, 6 ]
```

정렬된 부분은 현재 비어 있고 더미는 `8`부터 시작한다.

첫 번째 숫자를 처리하고 난 뒤에 상태는 다음과 같다.

```
[ 8 | 3, 5, 4, 6 ]
```
이제 정렬된 부분은 `[ 8 ]`이고 더미는 `[ 3, 5, 4, 6 ]`이다. `|`는 오른쪽으로 한 칸 이동하였다.

배열의 숫자들이 정렬되는 과정은 다음과 같다.

```
[| 8, 3, 5, 4, 6 ]
[ 8 | 3, 5, 4, 6 ]
[ 3, 8 | 5, 4, 6 ]
[ 3, 5, 8 | 4, 6 ]
[ 3, 4, 5, 8 | 6 ]
[ 3, 4, 5, 6, 8 |]
```

각 단계마다 `|`는 한 칸씩 자리를 옮긴다. 배열의 시작점부터 `|` 직전까지는 항상 정렬되어 있다. 단계마다 더미는 하나씩 줄어들고 정렬된 부분은 늘어난다. 이 과정은 정렬되지 않은 부분이 남지 않을 때까지 계속된다.

## 삽입하기

더미에서 숫자를 가져와 정렬된 부분에 삽입하려고 할 때, 어느 위치에 삽입하여야 정렬된 상태가 유지될 수 있을까?

몇 개의 숫자들은 이미 정렬되어 있는 다음의 상태를 가정하자.

```
[ 3, 5, 8 | 4, 6 ]
```

다음으로 정렬할 대상은 `4`이다. `[ 3, 5, 8 ]` 중 어느 위치에 삽입할 것인지 결정해야 한다.

한 가지 방법은 직전 원소인 `8`과 비교하는 것이다.

```
[ 3, 5, 8, 4 | 6 ]
        ^
```

`8`은 `4`보다 크다. 그러므로 `4`는 `8`보다 앞에 위치하여야 한다. 두 숫자의 자리를 바꾼다.

```
[ 3, 5, 4, 8 | 6 ]
        <-->
        자리 바꿈
```

정렬은 아직 끝나지 않았다. `4` 앞에 여전히 더 큰 `5`가 존재한다. 두 숫자의 자리를 바꾼다.

```
[ 3, 4, 5, 8 | 6 ]
     <-->
     자리 바꿈
```

다시 `3`과 `4`를 비교한다. `3`이 더 작으므로 이제 `4`는 제자리를 찾은 것이다. 정렬은 끝나고 배열의 앞부분은 정렬된 상태로 유지된다.

삽입에 대한 지금까지의 설명은 삽입 정렬의 안쪽 루프에 대한 것이었다. 다음 문단에서 코드로 살펴보자.

## 코드

다음은 Swift로 구현된 삽입 정렬 코드이다.

```swift
func insertionSort(_ array: [Int]) -> [Int] {
    var a = array			 // 1
    for x in 1..<a.count {		 // 2
        var y = x
        while y > 0 && a[y] < a[y - 1] { // 3
            a.swapAt(y - 1, y)
            y -= 1
        }
    }
    return a
}
```

이 코드를 playground에 넣고 아래 코드로 시험해보자.

```swift
let list = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(list)
```

삽입 정렬 코드를 단계별로 살펴보자.

1. 전달 받은 배열의 복사본을 만든다. 매개 변수인 `array`는 직접적으로 수정할 수 없기 때문이다. Swift의 함수 `sort()`처럼 `insertionSort()`도 원본 배열의 *복사본*을 정렬하여 반환한다.

2. 함수 안에는 두 개의 루프가 존재한다. 바깥쪽 루프는 배열의 원소들을 하나씩 차례대로 돈다. 더미에서 가장 위에 있는 숫자를 하나씩 골라오는 것이 이것에 해당한다. 변수 `x`는 정렬된 부분이 끝나는 지점이자 더미가 시작되는 지점의 인덱스이다. 즉 `|`의 위치이다. 인덱스 0부터 `x`까지에 해당하는 배열은 언제나 정렬되어 있다는 사실을 잘 기억해두자. `x` 이후의 부분은 정렬되지 않은 더미이다.

3. 안쪽 루프에서는 인덱스 `x`에서의 값을 바라본다. 이 값은 더미에서 가장 위에 있는 숫자이고, 보다 앞쪽에 있는 숫자들보다 작을 가능성이 있다. 안쪽 루프는 앞쪽의 정렬된 배열을 거꾸로 돌면서 대소를 비교한다. 큰 숫자를 만날 때마다 자리를 교체한다. 이 안쪽 루프가 한번 끝나고 나면 배열의 앞쪽 부분은 다시 정렬된 상태가 되어 원소가 하나 증가한다.

> **노트:** 바깥쪽 루프는 인덱스가 0 대신 1부터 시작한다. 최초에 첫 번째 원소를 빈 배열로 옮기는 일은 굳이 필요하지 않기 때문에 생략한 것이다.

## 자리 교체 한번으로 줄이기

`swap()` 함수의 호출을 줄여서 삽입 정렬의 속도를 개선할 수 있다.

정렬 상태를 유지하기 위하여 지금까지는 이런 식으로 자리를 바꾸었다.

```
[ 3, 5, 8, 4 | 6 ]
        <-->
        swap
	        
[ 3, 5, 4, 8 | 6 ]
     <-->
     swap
```

직전 원소와 매번 자리를 바꾸는 대신에, 직전 원소를 오른쪽으로 옮기고 나서 추가할 원소를 올바른 위치에 복사하면 된다.

```
[ 3, 5, 8, 4 | 6 ]   4를 기억해둔다
           *

[ 3, 5, 8, 8 | 6 ]   8을 오른쪽으로 옮긴다
        --->
	        
[ 3, 5, 5, 8 | 6 ]   5를 오른쪽으로 옮긴다
     --->
	     
[ 3, 4, 5, 8 | 6 ]   4를 올바른 자리에 복사한다
     *
```

코드는 다음과 같다.

```swift
func insertionSort(_ array: [Int]) -> [Int] {
  var a = array
  for x in 1..<a.count {
    var y = x
    let temp = a[y]
    while y > 0 && temp < a[y - 1] {
      a[y] = a[y - 1]                // 1
      y -= 1
    }
    a[y] = temp                      // 2
  }
  return a
}
```

`// 1`에서 직전 원소를 한 칸 옮긴다. 안쪽 루프의 마지막을 보면 `y`는 새로운 원소가 들어갈 자리의 인덱스인 것을 알 수 있다. 그리고 `// 2`에서 새 원소가 그 자리에 추가된다.

## 제네릭하게 만들기

숫자 외에 다른 것들도 정렬이 가능하게 만들어보자. 배열 안의 데이터 타입을 제네릭하게 만들고, 사용자가 직접 함수 (또는 클로저)를 전달하여 대소 비교가 가능하도록 만들 것이다. 코드의 두 군데만 고치면 된다.

함수의 시그니처는 다음과 같다.

```swift
func insertionSort<T>(_ array: [T], _ isOrderedBefore: (T, T) -> Bool) -> [T] {
```

이 배열은 `[T]` 타입의 원소를 가지는데, `T`란 제네릭하게 구현하기 위한 자리 표시 역할(placeholder)을 한다. 이제부터 `insertionSort()`는 숫자, 문자열 등 어떤 종류의 데이터 타입 배열도 받아들일 수 있다.

새로운 매개 변수인 `isOrderedBefore: (T, T) -> Bool`은 두 개의 `T` 객체를 받아서, 첫 번째 객체가 두 번째 것보다 앞에 위치하면 true를 반환하고, 그 반대라면 false를 반환하는 함수이다. Swift의 내장된 `sort()` 함수와 같은 방식이다.

안쪽 루프의 코드를 살짝 수정한다.

```swift
while y > 0 && isOrderedBefore(temp, a[y - 1]) {
```

`temp < a[y - 1]` 대신 `isOrderedBefore()`를 호출하여 숫자 이외에 데이터도 비교 가능하도록 한다.

playground에서 다음과 같이 시험해보자.

```swift
let numbers = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(numbers, <)
insertionSort(numbers, >)
```

`<`과 `>`로 정렬의 순서를 결정한다. 각각 오름차순과 내림차순에 해당한다.

이처럼 문자열끼리도 대소를 비교할 수 있다.

```swift
let strings = [ "b", "a", "d", "c", "e" ]
insertionSort(strings, <)
```

심지어는 더 복잡한 객체에서도 가능하다.

```swift
let objects = [ obj1, obj2, obj3, ... ]
insertionSort(objects) { $0.priority < $1.priority }
```

위에 클로저에서 보이듯 객체의 `priority` 프로퍼티를 근거로 하여 `insertionSort()`하도록 할 수 있다.

삽입 정렬은 *안정* 정렬의 일종이다. 안정 정렬이란 동일한 값에 대하여 정렬 후에도 기존의 순서가 유지되는 정렬을 뜻한다. 숫자나 문자열 같이 단순한 값을 다룰 때에는 크게 중요한 문제가 아니지만, 더 복잡한 객체를 다룰 때에는 중요할 수 있다. 앞의 예를 들어 두 객체가 같은 `priority`를 가지고 있다고 할 때, 안정 정렬에서는 객체가 가지고 있는 값에 상관 없이 두 객체는 자리가 뒤바뀌지 않는다.

## 성능

배열이 이미 정렬되어 있는 경우 삽입 정렬은 매우 빠른 속도를 보인다. 당연한 것처럼 들리겠지만 모든 정렬 알고리즘이 이런 것은 아니다. 현실에서 데이터가 이미 꽤 정렬되어 있는 경우가 있는데 이 때 삽입 정렬은 좋은 성능을 보인다.

최악에 경우에 삽입 정렬의 성능은 **O(n^2)** 이다. 내부에 두 개의 루프가 있기 때문이다. 퀵 정렬(quick sort)나 병합 정렬(merge sort)와 같은 알고리즘들은 **O(n log n)** 의 성능을 보이는데, 큰 입력이 주어졌을 때 훨씬 빠르게 작동한다.

삽입 정렬은 작은 크기의 배열이 주어졌을 때 굉장한 성능을 보인다. 어떤 표준 라이브러리들에서는 정렬 함수를, 크기 10개를 기준으로 퀵 정렬과 삽입 정렬로 구분하여 구현하기도 한다.

`insertionSort()`과 Swift 내장 함수인 `sort()`를 비교해 보았다. 100개 정도의 아이템들로 구성된 배열에서 속도 차이는 크지 않았다. 그러나 점점 커질수록 삽입 정렬은 **O(n^2)** 의 성능을 보이면서 **O(n log n)** 보다 나빠지기 시작하였고, 따라잡을 수 없었다.

## 참고하면 좋은 자료

[Insertion sort on Wikipedia](https://en.wikipedia.org/wiki/Insertion_sort)

## References

- [Insertion Sort - Swift Algorithm Club](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Insertion%20Sort)