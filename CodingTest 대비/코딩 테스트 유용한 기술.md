# 코딩 테스트 유용한 기술

## 문자열이 숫자인지 판별하는 방법

```java
public static boolean isNumeric(String s) {
  try {
      Double.parseDouble(s);
      return true;
  } catch(NumberFormatException e) {
      return false;
  }
}
```
이 메소드를 선언해 숫자를 판별한다.

## 문자열 마지막을 자르는 방법
```java
if (str.length() > 0) {
			str = str.substring(0, str.length() - 1);
		}
```
문자열이 비어 있는지 먼저 체크해준 뒤, 마지막을 자른다.

## Stream에서 List로 만들기
```java
Stream<String> language = Stream.of("java", "python", "node");

//Convert a Stream to List
List<String> result = language.collect(Collectors.toList());
```
Collectors.toList() 메서드를 이용해 Stream을 List로 만들게 된다.

## 최대 연속 부분합(Maximum SubArray Sum)

-  Greedy Algorithm: 현재 가장 좋은 선택(부분해)이 최종적으로 좋은 선택이 될 것이라는 가정 아래 진행.

  (1) 현재 조회하는 숫자를 현재까지의 합에 추가하였을 때 0과 비교해 0보다 작으면 0을, 크다면 더한 값을 현재까지의 합으로 한다.

  (2) 지금까지 최댓값과 현재까지의 합을 비교해 더 큰값을 최댓값으로 둔다.

``` java
public static int sequence(int[] arr) {
  int max_ending_here = 0;
  int max_so_far = 0;

  for (int num: arr) {
    max_ending_here = Math.max(0, max_ending_here + num);
    max_so_far = Math.max(max_so_far, max_ending_here);
  }

  return max_so_far;
}
```
-  Dynamic Programming: 점화식으로 통해 짜는 것.

  (1) i index까지의 최대 합을 MaxSum(i)라 하자.

  (2) i가 0일 때는 MaxSum(0) = Max(arr[0], 0);

  (3) i >= 1일 때, MaxSum(i) = Max(MaxSum(i - 1) + arr[i], arr[i]);

``` java
public static int sequence(int[] arr) {
  // Dynamic Programming
  // MS(MaxSum)(i) = Max(MS(i-1) + A[i], A[i]);
  // MS(0) = Max(A[0], 0);
  int[] memoization = new int[arr.length];

  return maxSumUntil(arr, memoization, arr.length);
}

public static int maxSumUntil(int[] arr, int[] memoization, int i) {
  if (arr.length == 0) {
    return 0;
  }
  // 초기값 설정
  memoization[0] = Math.max(arr[0], 0);
  int max = memoization[0];
  for (int j = 1; j < i; j++) {
    memoization[j] = Math.max(memoization[j - 1] + arr[j], arr[j]);
    max = Math.max(memoization[j], max);
  }

  return max;
}
```
