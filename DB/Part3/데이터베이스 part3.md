# 데이터베이스 part3

# 5장 RDB Functions

## View
- 사용자마다 스키마를 선택적으로 보여줄 수 있다.
- `Crate view`로 생성한다.
- 실질적으로 존재하는 테이블이 아니라 `베이스 테이블`로부터 생성되는 `가상 테이블`이라 할 수 있다.
- 항상 최신의 상태를 유지한다.
- 뷰에서 뷰를 다시 만들 수도 있음.

### View Expansion
더 이상 뷰가 없는 상태로 만들어 `베이스 테이블`로 이루어지게끔 루프를 돌며 반복하는것

### View의 업데이트 조건
- "from" 절이 하나의 데이터베이스 테이블을 가져야 함.
- "select" 절은 릴레이션의 속성 이름만을 가져야 하며 다른 `expressions`나 `aggregates`, `distinct`를 가지면 안됨.
- "select" 절에 없는 속성 값은 `null`로 할 수 있어야 함.
- query는 "group by"나 "having" 절을 가지면 안 된다.

## Materialized Views
View가 tuple을 가지는 경우.

왜 쓸까?
- 질의문의 빠른 처리.

## 무결성 제약
- DBMS가 항상 만족해야하는 제약.
- 데이터베이스의 `정확성`, `일관성`을 보장하기 위해서 사용.

### 참조 무결성 제약
- R에 있는 모든 A값이 S에 나오거나 또는 A가 `null` 값이면 A는 외래키다.
- 참조하는 값이 무조건 있어야(또는 `null`) 하기 때문에 함부로 지울 수 없다.

## Authorization
데이터베이스 자체적으로 접근을 제한하거나 허용하는 기능을 가지고 있어야 함.
- DBA: **superuser**. 모든 권한을 가지고 있음.

인스턴스 / 스키마를 조작하는 권한으로 나눌 수 있다.
> 외래키 설정도 권한을 가진 사용자만 가능.

- `Grant`: 권한을 허용.
- `Revoke`: 권한을 회수.
> 중복으로 권한을 줄 수 있으며 대신 **여러 번** 회수 해야함.

### Authorization Graph
- `노드`를 사용자로 하여 `간선`으로 권한을 준 것을 표현한다.
- `루트 노드`는 `DBA(관리자)`가 된다.
- 시스템이 유지.

### Authorization on Views
- 뷰를 만든 사용자는 그 테이블에 대해 모든 권한을 가지지는 않는다.
- 그 사용자의 권한 위의 권한을 가지지 못함.

### SQL 권한 기능의 한계
- `tuple` 레벨까지 권한 기능을 제어할 수는 없다.
  - 특정 튜플에게 권한 부여 불가.
- 많은 사용자들은 하나의 **웹 프로세스**로 DB에 접근하게 되기 때문에 DB입장에서는 하나의 유저를 관리하는 것처럼 보임. 대신 어플리케이션 단에서 많은 사용자를 관리함.
  - 장점: 각각의 사용자에게 권한 부여 가능
  - 단점: 어플리케이션 코드 안에서 인증을 해야되기 때문에 너무 많은 분산이 일어날 수도 있음.

## 재귀적 쿼리
재귀적 쿼리를 지원하지 않으면 응용프로그램 단에서 루프를 돌려야 함.

- 재귀적 뷰는 반드시 `monotonic`해야 함: **이전에 구한 데이터가 남아 있고 여기에 계속 더해지는 것**.
  - 이것이 되지 않으면 loop가 끝나지 않음.

# 6장 Applications
DB 응용을 어떻게 할 것인가?

## 내장 SQL(Embedded SQL)
- 기본 프로그래밍 언어인 `host language` 안에서 SQL 언어를 정의하여 사용.
- 컴파일 전에 `preprocess`를 거쳐 호스트 언어가 이해할 수 있도록 처리됨.

### Cursors
데이터베이스 언어와 프로그래밍 언어가 조화가 되지 않을 때 해결하는 기법.
- 다루는 자료형의 특성이 다루기 때문에 부조화가 발생.
- 호스트 언어가 쓰는 타입으로 매핑해주기. `for update`키워드를 명시해줘야 업데이트가 이루어짐.

## 동적 SQL(Dynamic SQL)
기존과 달리 **런타임** 시에 SQL 문이 정해지는 것.

### OBDC / JDBC
- ODBC: c, c#, c++에서 사용하는 API
- JDBC: Java에서 사용.
