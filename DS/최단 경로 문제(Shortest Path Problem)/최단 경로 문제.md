# 최단 경로 문제
가중 방향 그래프 *G* = (*V*,*E*)에서 가중치가 가장 적은 경로 *p*를 찾는 문제이다. 일반적으로 두 정점 사이의 최단 경로가 그 안에 다른 최단 경로를 포함한다는 특성을 이용한다. 이러한 **최적 부분 구조** 특성은 **동적 프로그래밍**과 **그리디 알고리즘**을 사용하게 한다.

대표적으로 단일 출발지 최단 경로 문제를 해결하는 **다익스트라 알고리즘**은 그리디 알고리즘을, 모든 정점 쌍 간의 최단 경로를 찾는 **플로이드-와샬 알고리즘**은 동적 프로그래밍 알고리즘을 사용한다.

## 최적 부분 구조의 증명
이러한 경로가 있다고 해보자.
``` 
u ~> x ~> y ~> v
```

정점 *u*에서 정점 *v*까지 이르는 최단 경로를 *P*라고 하자.
그러면 최소의 가중치 w(u, v) = w(u, x) + w(x, y) + w(y, v) 가 성립할 것이다.

이 때, 정점 *x*에서 *y*까지 이르는 더 짧은 경로가 있다고 가정하면, 다음이 성립한다.

``` 
w'(u, v) = w(u, x) + w'(x, y) + w(y, v)
         < w(u, x) + w(x, y) + w(y, v) = w(u, v)
```
이렇게 되면, 우리가 처음에 했던 최단 경로가 *P*라는 가정을 위배하게 된다. 이를 통해 최적 부분 구조 특성을 지닌다고 할 수 있다. 이러한 특성을 이용해 동적 프로그래밍과 그리디 알고리즘 기법을 적용할 수 있다.
                    
## 단일 출발지 최단 경로 문제
문제를 해결하기 위해 공통적으로 쓰이는 것들이 있다. 각 정점 v에 대해 출발지 *s*로부터 *v*까지의 최단 경로 가중치의 상한 *v.d*를 유지하며 이 값은 최종적인 값, **최단 경로 추정값**이 될 수 있다.

#### 초기화
추정값과 직전 원소를 초기화하는 작업으로 O(V) 시간이 걸린다.

``` Swift
INITIALIZE-SINGLE-SOURCE(G, s) {
    for v in V[G] {
        v.d = ∞
        v.π = nil
    }
    s.d = 0
}
```

#### 완화(Relaxation)
간선을 추가하기 전에 지금까지 발견된 최단 경로를 개선할 수 있는지 체크하고, 개선 할 수 있다면 *v.d*와 *v.π*를 갱신하는 것이다. O(1) 시간이 걸린다.

``` Swift
RELAX(u, v, w) {
    if v.d > u.d + w(u, v) { // 개선할 수 있는지 검사
        v.d = u.d + w(u, v) // v.d 개선
        v.π = u
    }
}
```
### 벨만-포드 알고리즘
벨만-포드 알고리즘은 **간선의 가중치가 음수를 가지는 그래프에도 적용이 가능**하다. 출발점으로부터 도달 가능한 **음의 가중치를 갖는 순환이 있는지를 나타내는 논리값을 리턴**한다. 이 때 만약 순환이 있다면 최단 경로가 존재하지 않는다는 것을 표시하고, 없다면 최단 경로와 그 경로의 가중치를 계산한다. 

``` Swift
BELLMAN-FORD(G, w, s) {
    INITIALIZE-SINGLE-SOURCE(G, s)
    for i = 1 to |G.V| - 1 {
        // 시작 정점을 제외한 모든 정점의 수만큼 RELAX 실행.
        for 각 간선 (u, v) in G.E { 
            RELAX(u, v, w)
        }
    }
    for 각 간선 (u, v) in G.E {
        // 한 번이라도 업데이트가 일어나면 '음의 가중치 순환'이 존재하므로 false를 반환.
        if v.d > u.d + w(u, v) {
            return false 
        }
    }
    
    return true
}
```

#### 시간 복잡도
초기화 시 O(V), 두 번째 for 문에서 O(E)만큼 걸린다. 그런데 첫 번째 for 문에서 O(V * E)가 걸리므로 최종 시간 복잡도는 O(VE)가 된다.

### 다익스트라 알고리즘
다익스트라 알고리즘은 벨만-포드 알고리즘과 달리 모든 간선의 가중치가 음이 아닌 경우에만 적용이 가능하다. 하지만 효율적으로 구현하는 경우 더 빠르다. 다익스트라 알고리즘은 **너비 우선 탐색**을 기반으로 한다.

알고리즘은 다음과 같이 진행된다.

1. 시작점의 거리를 0으로, 나머지 점들의 거리를 ∞로 하는 초기화를 한다.
2. 가중치가 결정된 정점의 집합 S, 거리 *d*의 값을 키 값으로 하는 우선순위 큐 *Q*를 초기화한다.
3. *Q*가 빌 때까지 정점을 돌며 완화작업을 한다.

``` Swift
DIJKSTRA(G, w, s) {
    INITIALIZE-SINGLE-SOURCE(G, s)
    S = ø
    Q = G.V
    while Q != ø {
        u = EXTRACT-MIN(Q)
        S = S ∪ {u}
        for 각 정점 v in G.Adj[u] {
            RELAX(u, v, w)
        }
    }
}
```

#### 시간 복잡도
다익스트라 알고리즘도 어떠한 자료구조로 우선순위 큐를 구현하는 가에 따라 시간 복잡도가 달라진다.
공통적으로 초기화 시, 우선순위 큐 *Q*에 정점을 넣는 연산, 그리고 while 문에서 O(V)가 걸린다.

while 문 안에서는 EXTRACT-MIN(Q) 연산이 어떠한 자료구조를 통해 이루어지느냐에 따라 달라진다.

- 배열의 경우
최악의 경우 모든 원소를 검사해야 하므로 O(V)가 걸린다. 간선은 한 번씩만 검사된다고 할 수 있으므로 O(E)의 시간이 걸리기 때문에 총 O(V<sup>2</sup> + E) 시간이 걸린다고 할 수 있다. 보통 dense graph의 경우 간선의 갯수가 정점의 갯수 제곱만큼 있으므로 O(V<sup>2</sup>)이라고도 볼 수 있다.
- 이진 힙의 경우(그래프가 충분히 sparse 할 경우)
최소 힙을 사용하면 O(lgV) 시간 내에 찾을 수 있다. 이 때는 RELAX 연산 안에서 일어나는 DECREASE-KEY 연산도 O(lgV) 시간 내에 일어나므로 최종적으로 O((E + V)lgV) 시간이 걸린다.

## 모든 쌍의 최단 경로
모든 정점의 쌍 사이의 가장 짧은 경로를 구하는 문제이다. 모든 정점 사이의 거리를 표시해야 하기 때문에 그래프를 인접 행렬로 보고 구하고 결과값도 행렬로 표시한다.

단순하게 생각하면 각 정점을 출발점으로 잡고 **단일 출발지 최단 경로 알고리즘**을 적용하면 되는 문제이다. 만약 가중치가 음수가 아니라면 다익스트라 알고리즘을 적용하고, 음수를 가진다면 벨만-포드 알고리즘을 적용한다.

### 플로이드-와샬 알고리즘
**동적 프로그래밍** 방식을 사용하는 알고리즘으로 이는 최단 경로 문제의 최적 부분 구조의 특성을 활용한 것이다. 이 알고리즘은 음의 가중치가 존재해도 순환이 없다면 잘 동작한다. 그러나 여기서는 음의 가중치를 가진 간선은 없다고 가정한다.

플로이드-와샬 알고리즘은 최단 경로의 **"중간(경유하는)"** 정점을 고려하여 만들어 진다. 이 알고리즘은 가중치를 표시하는 각 정점 경유 시 나타나는 가중치의 행렬 *D*<sup>(k)</sup>를 가진다.

#### 점화식
플로이드-와샬 알고리즘은 동적 프로그래밍을 사용하는 데 아래와 같은 점화식을 따른다.

여기서 i와 j는 각각 시작점과 도착점이며 k는 이번에 추가될 수 있는 경유 정점이다.

d<sub>ij</sub><sup>(k)</sup> 
= w<sub>ij</sub> (k = 0일 때)
= min (d<sub>ij</sub><sup>(k - 1)</sup>, d<sub>ik</sub><sup>(k - 1)</sup> + d<sub>kj</sub><sup>(k - 1)</sup>)

#### 의사 코드
``` Swift
FLOYD-WARSHALL(W) {
    n = W.rows
    D^0 = W
    for k = 1 to n {
        D^k = D^0
        for i = 1 to n {
            for j = 1 to n {
                D^k[i][j] = min(D^k-1[i][j], D^k-1[i][k] + D^k-1[k][j])
            }
        }
    }

    return D^n
}
```

#### 시간 복잡도
플로이드-와샬 알고리즘의 수행 시간은 삼중 for 문에 의해 결정된다. 즉, O(V<sup>3</sup>)시간이 걸린다.