# 해시 테이블(Hash Table)

해시 테이블은 **사전을 구현**하는 자료구조다. 내부적으로 기본적인 자료구조인 `배열`을 사용하기 때문에 원소를 찾을 때 `인덱스`로 접근하여 **평균적**(`충돌(collision)`의 경우가 존재하기 때문이다.)으로 `O(1)`의 시간이 걸린다.

## 직접 주소 테이블

이 기법은 `키(key)`들의 전체 집합이 적당히 작을 경우에 잘 동작하는 단순 기법으로 키들의 갯수만큼 배열을 만들어 그 위치에 넣어두는 것이다. 이렇게 할 경우 `기본 사전적 연산`은 매우 쉽다.

``` java
DIRECT-ADDRESS-SEARCH(T, k) {
  return T[k]
}

DIRECT-ADDRESS-INSERT(T, x) {
  T[x.key] = x
}  

DIRECT-ADDRESS-DELETE(T, x) {
  T[x.key] = nil
}
```

이 연산은 매우 빨라 최악의 경우에도 `O(1)`의 수행시간을 소요한다.

그러나, 키들의 전체 집합이 클 경우 이 기법은 불가능해진다.

## 해시 테이블

사전에 저장된 키들의 집합 *K*는 모든 가능한 키들의 전체 집합 *U*보다 훨씬 작을 확률이 크다. O(1)의 탐색 시간을 **평균적**으로 유지하되, 사용 공간을 *K* 집합의 갯수만큼 줄이는 방법은 `해시 함수(hash function)`을 사용하는 것이다.

### 해시 함수

*h*: *U* -> {0, 1, ..., *m* - 1} 로 표현이 되며 이 때 *m*은 해시 테이블의 크기이다. 해시 함수를 통해 키 *k*는 *h*(*k*) 위치에 저장이 되는데, 이 위치는 `해시 코드(hash code)`라고 불리기도 한다. 해시 함수를 통해 저장되는 키 값을 작은 범위의 값들로 바꿔준다.

하지만 어설픈 해시 함수를 사용할 경우 **동일한 위치에 서로 다른 키 값이 저장되는 현상**인 `충돌(collision)`이 많이 발생할 수 있게 된다.

좋은 해시 함수는 **다른 키가 해시된 위치와는 상관없이 각 키가 *m*개의 자리 중 하나에 같은 확률로 해시된다**라는 `단순 균등 해싱`의 가정을 만족한다. 그러나 이 가정을 검사하는 것은 불가능하다. 왜냐하면 키가 추출되는 확률 분포를 알 수 없고 키가 독립적으로 추출되지 않을 수도 있기 때문이다. 실제로는 키의 특성을 고려해서 `휴리스틱`하게 해시 함수를 설계한다고 한다.

## 충돌 해결 방법

기본적으로 두 가지 방법이 존재한다.

### 체이닝(chaining)

`체이닝`은 **같은 위치에 해시되는 모든 원소를 연결 리스트에 넣는** 방식이다. `연결 리스트`의 특성을 살려 `삽입`과 `삭제`는 매우 간단하다. 그러나 `검색`의 경우 `연결 리스트`의 특성상 처음부터 탐색을 진행해야 하기 때문에 최악의 경우 리스트의 길이에 비례하는 소요시간이 든다.

``` java
CHAINED-HASH-SEARCH(T, x) {
  리스트 T[h(x.key)]의 맨 앞에 x 삽입
}

CHAINED-HASH-SEARCH(T, k) {
  리스트 T[h(k)]에서 키 k를 가지는 원소를 검색
}

CHAINED-HASH-DELETE(T, x) {
  리스트 T[h(x.key)]에서 x를 삭제
}
```

### 개방 주소화 방법(open-addressing)

이 방법은 모든 원소가 해시 테이블 그 자체에 저장되는 방식이다. 즉, **현재 키가 저장될 위치에 다른 키가 있다면 다른 위치를 찾아 저장**하는 것이다. 따라서 `삽입`을 할 경우 빈 공간을 찾기 위한 조사가 **연속**해서 이루어지며, 이는 고정된 순서가 아닌 **삽입된 키에 기반하여 결정**된다.

`체이닝`과 달리 테이블 외부에 저장된 리스트나 원소가 없기 때문에 `개방 주소화 방법`에서는 테이블이 **꽉 차서** `삽입`이 더 이상 불가능할 수도 있다. 외부에 저장되지 않기 때문에 그만큼 절약된 메모리는 해시 테이블 저장 공간의 확장에 이용된다.

``` java
HASH-INSERT(T, k) {
  i = 0
  repeat
    j = h(k, i)
    if T[j] == nil {
      T[j] = k
      return j
    } else {
      i = i + 1
    }
  until i == m
  error "해시 테이블 포화"
}

HASH-SERACH(T, k) {
  i = 0
  repeat
    j = h(k, i)
    if T[j] == k {
      return j
    }
    i = i + 1
  until T[j] == nil or i == m
  return nil
}
```

`삭제`의 경우 조금 복잡해진다. 단순히 `nil`로 처리하면 안 되는 이유는 다른 원소를 삽입 시 이 위치가 차 있다는 사실을 알고 넘어간 키를 나중에 검색하는 것이 불가능해진다. 대신 `DELETED`라는 특별한 값을 저장하여 해결을 할 수 있다.

다음은 조사 순서를 계산하는 방법이다.

- 선형 조사: 순차적으로 탐색.
- 2차원 조사: 2차 함수를 통해 탐색.
- 중복 해싱: 해시 함수를 추가적으로 적용.

## Reference

- Introduction to Algorithms, 3rd edition, Thomas H. Cormen, 한빛 아케데미
- Cracking the Coding Interview, Gayle Laakmann McDowell, 인사이트
