# 힙 (Heap)

**들어가기에 앞서**

- 이 글은 [*Kevin Randrup*](http://www.github.com/kevinrandrup)과 *Matthijs Hollemans*가 최초 작성하였고, [*Kangsoo Lee*](https://github.com/oaksong)가 한국어로 번역하였습니다.
- 소스 코드와 예제 프로젝트는 Swift Algorithm Club의 [원 글 저장소](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap)에서 확인할 수 있습니다.
- Swift Algorithm Club의 [한국어 번역판 저장소](https://github.com/oaksong/swift-algorithm-club-ko)에서 더 많은 자료를 만나보세요.

---

> [이곳](https://www.raywenderlich.com/160631/swift-algorithm-club-heap-and-priority-queue-data-structure)에서 이 주제에 대한 튜토리얼을 볼 수 있다.

힙은 배열(array)을 기반으로 한 트리이다. 따라서 부모와 자식 포인터가 필요 없다. 트리을 구성하는 노드들의 순서는 "힙 프로퍼티(heap property)"에 의해 결정된다.

힙은 주로 다음과 같은 경우에 사용된다.

- 우선순위 큐(priority queue)를 구현할 때
- 힙 정렬(heap sort)에서
- 최소값 또는 최대값을 빠르게 찾고자 할 때
- 프로그래머가 아닌 친구들에게 감명을 주고 싶을 때

## 힙 프로퍼티

힙에는 두 가지 종류가 있다. 트리의 노드들이 저장되는 순서에 따라 *최대 힙(max heap)*과 *최소 힙(min heap)*으로 구분된다.

최대 힙에서 부모 노드는 자식 노드들보다 항상 큰 값을 가진다. 최소 힙에서는 부모 노드가 자식 노드들보다 항상 작은 값을 가진다. 이것을 "힙 프로퍼티"라고 부르며 트리를 구성하는 모든 노드들에 적용된다.

예를 하나 보자.

![A max-heap](images/Heap1.png)

모든 부모 노드들이 자식 노드들보다 큰 값을 가지는 것으로 보아 최대 힙이다. `(10)`은 `(7)`과 `(2)`보다 크다. 그리고 `(7)`은 `(5)`와 `(1)`보다 크다.

힙 프로퍼티 때문에 이 최대 힙의 최대값은 항상 루트 노드에 위치한다. 최소 힙의 경우에는 루트 노드에 항상 최소값이 위치한다. 힙은 우선순위 큐를 구현하기 위해 자주 사용되는데, 이 때 힙 프로퍼티 덕에 "가장 중요한(most important)" 원소를 빠르게 찾을 수 있다.

> **노트:** 힙의 루트 노드는 최대값 또는 최소값을 가지지만, 나머지 노드들의 순서는 예측이 불가능하다. 예를 들어 최대 힙에서 0번째 인덱스에서 항상 최대값을 가지지만 마지막 인덱스에서 항상 최소값을 가지는 것은 아니다. 그나마 보장되는 것은 리프 노드들 중 하나에 최소값이 있다는 것이다.

## 힙은 일반 트리와 무엇이 다를까?

힙은 이진 탐색 트리를 대체하지 않는다. 그리고 이 둘 사이에는 공통점과 차이점이 있다. 차이점들은 다음과 같다.

**노드의 순서.** 이진 탐색 트리(BST)에서 왼쪽 자식은 부모보다 항상 작고, 오른쪽 자식은 항상 커야 한다. 이것은 힙에는 적용되지 않는다. 최대 힙에서 두 자식은 모두 부모보다 작아야 한다. 반대로 최소 힙에서는 자식들 모두 부모보다 커야 한다.

**메모리.** 일반적인 트리를 사용하면 데이터를 저장하는 것 이상으로 데이터가 소요된다. 노드 객체와 양쪽 자식들로의 포인터를 저장하기 위한 공간을 할당해야 하기 때문이다. 힙은 그저 배열을 사용하여 값을 저장할 뿐 포인터는 필요로 하지 않는다.

**균형잡기.** 이진 탐색 트리가 **O(log n)**의 성능을 내기 위해서는 반드시 균형잡힌(balanced) 상태를 유지하여야 한다. 이를 위해 임의의 순서로 데이터를 삽입하고 삭제하거나, AVL 트리 또는 레드블랙 트리를 이용할 수 있다. 반면에 힙에서는 트리 전체가 정렬될 필요는 없다. 힙 프로퍼티에만 충족하면 된다. 따라서 균형을 잡는 것은 중요하지 않다. 힙은 구성되는 방식으로 인해 **O(log n)**의 성능이 보장된다.

**탐색.** 이진 트리를 사용하면 빠른 탐색이 가능하지만 힙에서는 그렇지 않다. 힙의 주요 목적은 최대값 또는 최소값을 가진 노드를 빠르게 찾는 것과, 신속하게 노드를 삽입하고 삭제하는 것이다. 특정 노드를 빠르게 탐색하는 것은 높은 우선순위를 가지지 않는다.

## 배열 속 트리

배열로 트리 구조를 구현한다고 하면 이상하게 들릴 수 있겠지만, 시간과 공간을 효율적으로 사용할 수 있다.

위에서 예로 든 트리를 저장해보자.

```
[ 10, 7, 2, 5, 1 ]
```

그런데 포인터를 사용하지 않고서 어느 노드가 부모이고 어느 노드가 자식인지 어떻게 알 수 있을까? 좋은 질문이다! 트리를 구성하는 노드의 배열 인덱스와 부모, 자식의 배열 인덱스 사이의 관계에 해답이 있다.

`i`를 어떤 노드의 인덱스라고 할 때 다음 공식들을 통해 이 노드의 부모와 자식의 인덱스를 알아낼 수 있다.

```
parent(i) = floor((i - 1)/2)
left(i)   = 2i + 1
right(i)  = 2i + 2
```

자세히 보면 `right(i)`은 `left(i) + 1`이다. 왼쪽과 오른쪽 노드는 항상 서로의 바로 옆에 위치한다.

이 공식들은 앞서 본 예시에 적용해보자.

| 노드 | 배열 인덱스 (`i`) | 부모 인덱스 | 왼쪽 자식 | 오른쪽 자식 |
|------|-------------|--------------|------------|-------------|
| 10 | 0 | -1 | 1 | 2 |
| 7 | 1 | 0 | 3 | 4 |
| 2 | 2 | 0 | 5 | 6 |
| 5 | 3 | 1 | 7 | 8 |
| 1 | 4 | 1 | 9 | 10 |

채워진 인덱스들이 실제로 맞는지 트리 그림을 보면서 직접 확인해보라.

> **노트:** 부모가 없는 루트 노드 `(10)`의 부모 인덱스는 `-1`로 채워져 있는데 이것은 유효한 인덱스가 아니다. 마찬가지로 자식 노드가 없는 `(2)`, `(5)`, `(1)`의 자식 인덱스들 또한 배열 크기의 크기를 초과한다. 따라서 인덱스를 사용하기 전에는 항상 유효한 인덱스인지 확인하여야 한다.

최대 힙에서 부모의 값은 항상 자식의 값보다 크거나 같아야 한다. 즉 다음의 공식은 모든 인덱스 `i`에서 참이어야 한다.

```swift
array[parent(i)] >= array[i]
```

예시로 든 배열이 이 부등식에 들어맞는지 확인해보라.

위 공식들을 쓰면 포인터의 도움 없이도 부모 또는 자식 인덱스를 찾을 수 있다. 이 방식은 기존처럼 포인터를 역참조하는 방식보다 까다롭게 느껴질 수 있다. 그렇지만 이것은 트레이드오프(tradeoff)이다. 부수적인 연산들이 더 해야하는 대신 메모리 공간을 아낄 수 있다. 다행히도 연산에 소요되는 시간은 **O(1)**으로 빠르다.

배열 인덱스와 트리 상의 위치 사이의 관계를 잘 이해하는 것이 중요하다. 다음은 15개의 노드를 포함하고 네 계층으로 구성된 힙 예시이다.

![Large heap](images/LargeHeap.png)

그림에 등장하는 숫자들은 노드의 값이 아니라 배열의 인덱스이다. 다음 그림은 배열의 인덱스와 트리의 층위을 연결지어 놓은 것이다.

![The heap array](images/Array.png)

그림에서 보이는 것처럼, 부모 노드가 자식 노드들보다 앞에 있어야 공식들이 성립할 수 있다.

다음 도식에는 제약 사항이 있다. 일반 이진 트리를 사용하여 이것을 구성하는 것은 가능하지만 힙으로는 불가능하다.

![Impossible with a heap](images/RegularTree.png)

힙의 가장 낮은 층위를 꽉 채우기 전까지는 다음 층위를 새롭게 구성할 수 없다. 그래서 힙은 항상 이런 식의 모양을 하고 있다.

![The shape of a heap](images/HeapShape.png)

> **노트:** 일반 이진 트리로 힙을 모방할 수 있겠지만 공간을 낭비하게 될 것이다. 중간에 빈 노드에 해당하는 배열의 인덱스에는 표시해두어야 할 것이다.

잠깐 퀴즈!

```
[ 10, 14, 25, 33, 81, 82, 99 ]
```

이 배열은 힙으로 볼 수 있을까? 정답은 그렇다 이다. 오름차순으로 정렬된 배열은 최소 힙으로 볼 수 있다. 이것을 그림으로 그려보면 다음과 같다.

![A sorted array is a valid heap](images/SortedArray.png)

최소 힙에서 부모는 항상 자식보다 작기 때문에 힙 프로퍼티는 모든 노드에서 유지된다. (내림차순인 배열과 최대 힙의 경우는 직접 증명해보라.)

> 노트: 그러나 모든 최소 힙이 반드시 정렬된 배열이어야 하는 것은 아니다! 즉 역은 성립하지 않는다. 힙을 정렬된 정렬된 배열로 되돌리려면 힙 정렬(heap sort)를 사용하면 된다.

## 수학을 더 해보자!

조금 더 나아가서, 힙의 다른 프로퍼티들을 표현하는 공식에 대해 알아보자. 이 부분은 알아두면 좋지만 반드시 알아야 하는 것은 아니니 생략해도 좋다!

트리의 *높이(height)* 는 루트 노드로에서부터 최하단 리프 노드까지 도달하는 데까지 걸리는 이동 횟수(step)으로 정의된다. 또는 정식적인 표현으로는 두 노드 사이의 간선의 수를 말한다. 높이 *h*의 힙은 *h + 1*개의 층위를 가진다.

이 힙의 높이는 3이므로 4개의 층위를 가진다.

![Large heap](images/LargeHeap.png)

*n*개의 노드로 구성된 힙의 높이 *h*는 *floor(log2(n))*이다. 왜냐하면 새로운 노드를 추가할 때 항상 가장 낮은 층위부터 가득 채우기 때문이다. 예시에서 노드는 15개이므로 높이는 `floor(log2(15)) = floor(3.91) = 3`이다.

가장 낮은 층위가 가득찼을 때 이 층위에는 *2^h*개의 노드가 존재한다고 볼 수 있다. 이 층위를 제외한 나머지 부분에는 *2^h - 1*개의 노드가 있다. 예시에서 가장 낮은 층위인 level 3에는 `2^3 = 8`개의 노드가 있고, level 0부터 2까지에는 `2^3 - 1 = 8 - 1 = 7`개의 노드가 있다.

따라서 힙을 구성하는 모든 노드의 수 *n*은 *2^(h+1) - 1*이다. 예시의 경우에는 `2^4 - 1 = 16 - 1 = 15`이다.

*n* 개의 노드로 구성된 힙에서 *l*번째 층위를 구성하는 노드의 개수(최상단에서 0부터 시작)는 최대 *ceil(n/2^(h+1-l))* 이다. 예시에서 level 2가 가질 수 있는 노드의 최대 개수는 `ceil(15/2^(3+1-2)) = 4`이다.

리프 노드들의 배열 인덱스는 항상 *floor(n/2)* 에서 *n-1* 사이에 있다. 이 사실을 활용하여 배열을 힙으로 빠르게 구성할 수 있다.

## 힙으로 무엇을 할 수 있을까?

힙에 원소를 삽입하거나 제거하고 나면 힙을 유효한 상태로 바로잡기 위해 추가적인 연산이 필요하다. 이 연산에는 두 가지가 있다.

- `shiftUp()`: 최대 힙에서 어떤 원소가 부모의 것보다 크거나 최소 힙에서 부모의 것보다 작다면, 이 둘의 자리를 바꾸어 줄 필요가 있다. 이 때 해당 원소는 트리를 따라 오르며 자리를 교체한다.

- `shiftDown()`반대로 부모 노드의 입장에서 자식보다 작거나 큰 경우에 부모는 트리를 따라 내려갈 필요가 있다. 이 연산은 "heapify"라 불리기도 한다.

원소를 올리거나 내리면서 자리를 교체하는 연산은 재귀적인 과정으로 **O(log n)** 의 시간이 소요된다.

위 두 가지의 기초 연산을 토대로 다음의 기능들을 구현할 수 있다.

- `insert(value)`: 새로운 원소를 힙의 마지막에 추가하고 `shiftUp()`를 호출하여 힙을 바로잡는다.

- `remove()`: 최대값(최대 힙에서) 또는 최소값(최소 힙에서)을 제거하고 반환한다. 비워진 공간을 채우기 위해 마지막 원소를 루트 노드 위치로 이동시키고 `shiftDown()`를 호출하여 힙을 바로잡는다. (이 연산은 "최소 추출" 또는 "최대 추출"이라고도 한다.)

- `removeAtIndex(index)`: 루트 노드에 위치한 원소 외에 다른 노드들도 제거 가능할 수 있다. 제거 후에 힙을 바로잡기 위해 `shiftDown()` 또는 `shiftUp()`이 호출한다.

- `replace(index, value)`: 특정 노드의 값을 작게(최소 힙에서) 또는 크게(최대 힙에서) 수정한다. 이후에 힙 프로퍼티에 어긋날 수 있기 때문에 `shiftUp()`를 호출하여 바로잡는다. ("키 감소" 또는 "키 증가"라고도 한다.)

앞의 네 가지 연산은 모두 **O(log n)** 의 시간을 소요한다. 원소를 올리거나 내리는 작업은 비용이 많이 들기 때문이다. 이제 소개할 연산들은 시간이 더 소요되는 것들이다.

- `search(value)`: 힙은 탐색에 효율적인 자료 구조가 아니다. 그럼에도 `replace()` 와 `removeAtIndex()` 을 사용하려면 인덱스를 찾아야 한다. 탐색에는 **O(n)** 시간이 든다.

- `buildHeap(array)`: `insert()`를 반복적으로 호출하여 정렬되지 않은 배열을 힙으로 변환시킨다. **O(n)** 시간이 든다.

- Heap sort: 힙은 배열이기 때문에 이것의 독특한 특성을 활용하여 배열을 오름차순으로 정렬할 수 있다. **O(n lg n).** 시간이 든다.

이외에도 `peek()`라는 함수를 사용하여, 원소를 제거하지 않으면서 힙의 최대값(최대 힙에서) 또는 최소값(최소 힙에서)을 반환받을 수 있다. **O(1)** 시간이 든다.

> **노트:** 단연 가장 흔히 쓰이는 것들은 새로운 원소를 추가하는 `insert()`와 최대값 또는 최소값을 제거하는 `remove()`이다. 둘 다 **O(log n)** 의 시간이 소요된다. 다른 연산들은 상급의 용도에서 쓰이는데, 예를 들어 새로운 원소가 추가되었을 때 "중요도(importance)"가 바뀌는 우선순위 큐(priority queue)를 만들 때 쓰인다.

## 힙에 원소 추가하기

예시를 통해 삽입이 구체적으로 어떻게 이루어지는지 확인해보자. `16`을 힙에 추가해보자.

![The heap before insertion](images/Heap1.png)

이 힙은 현재 배열로 표현하면 `[ 10, 7, 2, 5, 1 ]`이다.

새로운 원소를 힙에 추가하는 첫 번째 단계는 원소를 배열의 끝에 일단 붙이는 것이다. 그러면 이렇게 배열은 이렇게 될 것이다.

```
[ 10, 7, 2, 5, 1, 16 ]
```

이것을 트리로 표현하면 다음과 같다.

![The heap before insertion](images/Insert1.png)

`(16)`은 마지막 줄(층위)의 첫 번째 빈자리에 추가되었다.

안타깝게도 이렇게 되면 이 힙은 더 이상 힙 프로퍼티를 따르지 않는다. 왜냐하면 `(2)`가 `(16)` 위에 있는데 최대 힙에서는 큰 수가 작은 수보다 높은 곳에 위치해야 하기 때문이다.

힙 프로퍼티를 다시 따르기 위해 `(16)`과 ``(2)`를 스왑해보자.

![The heap before insertion](images/Insert2.png)

`(10)`은 `(16)`보다 작기 때문에 아직 끝나지 않는다. 새롭게 추가된 원소의 값이 그 부모의 값보다 작거나 꼭대기에 닿을 때까지 스왑을 계속한다. 이것을 **shift-up** 또는 **sifting** 이라고 하며 삽입 후에 반드시 이어지는 과정이다. 이 과정을 통해 너무 크거나 작은 값은 트리를 따라 "떠오르게" 된다.

최종적으로 다음과 같은 모양이 된다.

![The heap before insertion](images/Insert3.png)

이제 모든 부모는 다시 자식들보다 큰 값을 가지게 되었다.

shift-up 하는 데 드는 시간은 트리의 높이에 비례한다. 따라서 **O(log n)** 이 소요된다. (배열 끝에 요소를 붙이는 작업에는 **O(1)** 가 드는데, 이것은 미미한 시간이다.)

## 루트 노드 제거하기

트리에서 `(10)`를 제거해보자.

![The heap before removal](images/Heap1.png)

꼭대기의 빈 자리는 이제 어떻게 되는 걸까?

![The root is gone](images/Remove1.png)

삽입의 경우에는 새로운 원소를 배열의 끝에 두면 되었다. 제거는 정반대이다. 마지막 원소를 가져와서 트리의 꼭대기에 넣는다. 이후 힙 프로퍼티를 바로잡는다.

![The last node goes to the root](images/Remove2.png)

`(1)`의 **shift-down** 이 어떻게 일어나는지 보자. 최대 힙에서는 가장 큰 값이 꼭대기에 있어야 힙 프로퍼티가 유지된다. 스왑할 수 있는 후보로 `(7)`과 `(2)`가 있다. 이 중 더 큰 것을 선택하여 스왑한다. `(1)`과 `(7)`을 스왑하면 트리는 이렇게 된다.

![The last node goes to the root](images/Remove3.png)

자식이 없을 때까지 또는 자신보다 작은 자식들을 만날 때까지 shift-down을 계속한다. 이 예시에서는 한 번만 더 스왑하면 된다.

![The last node goes to the root](images/Remove4.png)

모든 shift-down이 완료될 때까지 소요되는 시간은 트리의 높이에 비례하여 **O(log n)** 이다.

> **노트:** `shiftUp()`과 `shiftDown()`는 한 번에 한 원소씩만 다룰 수 있다. 만약 다수의 원소의 위치가 어긋나 있다면, 한 원소씩 차례로 함수를 호출해야 한다.

## 특정 노드 제거하기

힙에서 노드를 제거한다고 하면 대부분의 경우 루트 노드를 제거할 것이다. 힙은 그런 용도로 디자인되었기 때문이다.

그렇지만 특정 노드를 제거할 수 있다면 더욱 유용할 것이다. `remove()` 함수를 일반화하여 구현할 수 있다. 구현에는 `shiftDown()` 이나 `shiftUp()`도 필요할 것이다.

앞선 예시로 돌아가 `(7)`을 제거해보자.

![The heap before removal](images/Heap1.png)

배열의 초기 상태는 다음과 같다.

```
[ 10, 7, 2, 5, 1 ]
```

알다시피 원소를 제거하면 힙 프로퍼티가 지켜지지 않을 가능성이 있다. 이를 바로잡기 위해 우선 제거할 원소를 배열의 마지막 원소와 스왑한다.

```
[ 10, 1, 2, 5, 7 ]
```

마지막 원소는 함수 종료 후에 반환될 것이다. `removeLast()`를 호출하여 힙에서 제거한다. 그리고 `(1)`는 자식보다 값이 작으므로 `shiftDown()`을 호출하여 `(5)`와 스왑하여 순서를 바로잡는다.

그런데 상황에 따라 shift-down이 아니라 shift-up을 호출해야 할 수도 있다. 다음 힙에서 `(5)`를 제거하는 상황을 고려해보자.

![We need to shift up](images/Remove5.png)

`(5)`와 `(8)`을 스왑하고 나서, `shiftUp()`을 호출하여 `(8)`과 부모를 스왑해야 한다.

## 배열을 힙으로 만들기

주어진 배열을 힙으로 만드는 기능이 있다면 편리할 것이다. 힙 프로퍼티가 만족될 때까지 배열의 원소들을 섞어주는 식으로 단순하게 구현할 수 있다.

코드로는 이렇다.

```swift
  private mutating func buildHeap(fromArray array: [T]) {
    for value in array {
      insert(value)
    }
  }
```

배열의 각각의 원소에 대해 단순히 `insert()`를 호출한다. 단순하지만 효율적이지 못하다. **n** 개의 원소가 각각 **log n** 시간을 소요하므로 총 **O(n log n)** 시간이 든다.

앞의 "수학을 더 해보자!" 부분에서 언급한 것처럼, 인덱스 *n/2* 부터 *n-1* 까지는 트리의 리프 노드에 해당한다. 리프 노드들은 생략해도 무관하다. 자식이 하나라도 있는 부모 노드들만이 잘못된 순서를 가질 수 있으므로 이것들만 처리하면 된다.

코드로는 이렇다.

```swift
  private mutating func buildHeap(fromArray array: [T]) {
    elements = array
    for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {
      shiftDown(index: i, heapSize: elements.count)
    }
  }
```

`elements`는 힙 내부의 배열이다. 이 배열을 거꾸로 하나씩 거쳐 가는데, 리프 노드가 아닌 노드들 중 첫 번째 노드에서부터 `shiftDown()`을 호출한다. 이 루프를 다 돌고 나면 생략했던 리프 노드들을 포함한 모든 노드들이 올바른 순서로 정렬된다. Floyd 알고리즘으로 알려진 이 알고리즘은 **O(n)** 시간 밖에 들지 않는다. 훨씬 좋다!

## 힙에서 특정 노드 찾기

힙은 빠른 탐색을 고려하여 만들어지지 않았지만, `removeAtIndex()`를 사용하여 특정 원소를 제거하거나, `replace()`를 사용하여 특정 노드의 값을 변경할 수 있다. 그러려면 대상 원소의 인덱스를 알아야 한다. 탐색을 통해 인덱스를 찾을 수 있기는 하지만 느리다.

노드들의 순서에 달려있기는 하지만 이진 탐색 트리에서는 빠른 탐색이 어느정도 보장된다. 힙은 이진 탐색 트리와 다른 방식으로 노드들의 순서를 결정하기 때문에 이진 탐색을 활용할 수 없다. 그저 모든 노드를 확인하는 수 밖에 없다.

힙 예시를 다시 보자.

![The heap](images/Heap1.png)

노드 `(1)`의 인덱스를 찾고자 한다면 배열 `[ 10, 7, 2, 5, 1 ]`을 선형적으로 탐색하면 된다.

힙이 탐색에 좋은 자료 구조가 아니기는 하지만 힙 프로퍼티를 통해 이점을 얻을 수 있다. 최대 힙에서 부모는 자식들보다 항상 크다는 특성을 이용하여, 찾고자 하는 값이 현재 값보다 이미 작다면 그 아래는 확인할 필요가 없다는 것을 알 수 있다.

예시 힙에서 (존재하지 않지만) `8`을 찾고 있다고 치자. `(10)`에서 시작하여 재귀적으로 자식들을 탐색할 것이다. 왼쪽 자식이 `(7)`인 것을 확인하였다면 그 아래에는 찾고 있는 값이 없다는 것을 확신할 수 있다. 오른쪽 자식 `(2)`도 마찬가지이다.

최적화를 위한 이런 노력에도 탐색에는 여전히 **O(n)** 시간이 소요된다.

> **노트:** 노드의 값과 인덱스를 맵핑하는 딕셔너리를 추가하여 **O(1)** 로 만드는 방법이 있다. 힙 기반의 우선순위 큐에서 `replace()`를 통해 "우선순위"를 자주 변경해야 한다면 이 방법을 사용해보는 것이 좋을 것이다.

## 코드

Heap.swift 파일에서 Swift로 구현한 힙을 확인해보라. 대부분의 코드들은 간단하게 느껴질 것이다. `shiftUp()`과 `shiftDown()`는 살짝 어렵게 느껴질 수도 있다.

`최대 힙`과 `최소 힙`을 구분하여 따로 구현하지 않고, `Heap` 객체 하나를 가지고 `isOrderedBefore` 클로저로 구분하였다. 이 클로저는 두 개의 값 사이의 순서를 결정하는 로직(logic)을 나타낸다. Swift의 `sort()` 메서드에서 아마 이런 방식을 본 적이 있을 것이다.

정수형 데이터로 구성된 최대 힙은 다음과 같이 만든다.

```swift
var maxHeap = Heap<Int>(sort: >)
```

최소 힙은 이렇다.

```swift
var minHeap = Heap<Int>(sort: <)
```

`isOrderedBefore()` 클로저를 사용하여 값의 대소를 비교한다는 점을 다시 한번 강조하고 싶다.

## 참고하면 좋을 것들

[Heap on Wikipedia](https://en.wikipedia.org/wiki/Heap_%28data_structure%29)

## References

- [Heap - Swift Algorithm Club](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap)
