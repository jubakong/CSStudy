# 네트워크 4차시

# Chapter3: Transport Layer
어플리케이션 프로세스 사이의 논리적 통신(logical communication)을 담당하는 계층.

## 트랜스포트 계층 vs. 네트워크 계층
- 트랜스포트 계층
    - 프로세스 to 프로세스
    - 네트워크 계층의 서비스에 의존
- 네트워크 계층
    - 호스트 to 호스트

## Multiplexing(다중화)/demultiplexing(역다중화)
- 보내는 쪽(송신): 어플리케이션 계층에서 *메시지*의 형태로 데이터를 주면 하나하나에 목적지 프로세스의 주소를 찍어 네트워크 계층에 이것들을 모아 한 줄로 내려보낸다. 이 과정이 *다중화*이다.
- 받는 쪽(수신): 올바른 주소로 전달하기 위해 *역다중화* 과정을 거친다. 이 때 사용되는 것이 **세그먼트의 헤더 안에 포함되어 있는 포트 번호**이다.

### 비연결형(Connectionless) 역다중화
- 포트번호를 갖는 소켓을 생성
- UDP 소켓은 목적지 IP 주소, 목적지 포트번호로 구분하여 이것이 같으면 같은 소켓에 전달

### 연결지향형(Connection-Oriented) 역다중화
- TCP는 4개 요소로 구분
    - 출발지 IP 주소, 출발지 포트번호
    - 목적지 IP 주소, 목적지 포트번호
- TCP에서는 하나의 어플리케이션이 여러 소스로부터 오는 것들을 각기 다른 소켓에서 받기 때문에 소스의 주소도 필요

## UDP: User Datagram Protocol
- IP에 최소 기능만 추가
- 최선형(best effort) 서비스
    - 손실이 날 수도 있음.
    - 순서가 어긋날 수도 있음.
- "connectionless"한 프로토콜로 핸드 셰이킹이 없고 각각의 세크먼트는 독립적으로 취급된다. 그렇기 때문에 위에서 언급한 문제점이 발생.
- 사용 예
    - 스트리밍 멀티미디어(손실 감내, 속도에 민감)
    - DNS
    - SNMP(네트워크 관리 프로토콜)
- UDP 상에서 신뢰적인 전송
    - 어플리케이션 계층에서 신뢰성을 추가
    - 어플리케이션에서 에러 복구

### UDP 세그먼트 헤더
지연을 유발하는 연결 설정이 없고 연결 상태를 담지 않기 때문에 헤더의 크기가 작아 패킷 오버헤드도 작다. 그래서 그만큼 빨리 전달할 수 있다.

### UDP 체크섬
전송된 세그먼트의 오류를 검출하는 것으로 16 bit 정수의 열을 통해 보수 합을 계산. 하지만 모든 에러를 다 발견할 수 없다.

## 신뢰성 있는 데이터 전송의 원리
다음의 요소를 갖추어야 한다.
- Checksum: 오류 검출.
- Acknowledgement: 잘 받았다는 것을 알려줌.
- Negative acknowledgement: 잘못 온 것을 알려줌.
- Timer: 일정 시간 내에 이뤄져야 함. 세그먼트나 ACK이 사라질 경우 다시 데이터를 요청하거나 보냄.
- Window, pipelining: 받았다는 ACK가 오지 않아도 계속 데이터를 넣음으로써 효율적으로 전송하도록 함.
- Sequence number: 보내는 것을 또 보내는 경우가 있기 때문에 붙여서 보냄.

## TCP: Transmission Control Protocol
- point to point(하나의 송신자, 하나의 수신자)
- 신뢰적인, 순서가 유지되는 바이트 스트림
- 파이프 라인
- full duplex: 양방향의 데이터 흐름.
- 송신 버퍼, 수신 버퍼를 유지
- 연결 지향형: 핸드 셰이킹을 통해 연결을 셋업.
- 흐름 제어(flow control)

### TCP 세그먼트 구조
- 시퀀스 넘버: 내가 실은 데이터의 스트림 번호.
- ACK: 상대방으로부터 기대하는 데이터의 번호.

![](images/ackseqScenario.png)

