# 네트워크 2차시

## Chapter 2: Application Layer

### Application architectures
네트워크 어플리케이션과 프로토콜이 아래 두 가지 구조를 가진다.

#### Client-server
- server
    - **언제나 on 상태**의 호스트
    - 영구적인 IP 주소
    - 데이터 센터의 형태로 큰 규모를 수행할 수 있음
- client
    - 서버랑 통신
    - 서로 통신하지는 않음
    - **간헐적**으로 연결
    - 동적인 IP 주소(인터넷이 연결될 때마다 변경될 수 있음)

#### P2P
서버가 없는 구조로 유저 시스템끼리 통신한다. 이 유저 시스템을 *peer*라고 한다. peer가 요청을 하기도 하고 받기도 한다.

P2P의 가장 큰 특징은 **self scalability**이다. 클라이언트-서버 구조에서는 서버가 규모 확장성을 지원하지만 P2P에서는 새 peer가 새 capacity를 갖고 오게 된다.

peer들이 간헐적으로 연결되고 IP 주소가 바뀌기 때문에 관리가 어렵다는 단점을 보인다.

### Process communicating
호스트끼리는 통신하지 않는다. 정확히 말하면 **호스트 안의 프로세스끼리** 통신을 하는 것이다. 통신하는 프로세스의 종류에는 두 가지가 있다.

- client process: 통신을 시작하는 프로세스.
- server process: 연결되기 기다리는 프로세스.

> P2P에서는 두 종류의 프로세스가 둘 다 있을 수도 있다.

#### Sockets
어플리케이션은 메시지를 만들고 이를 운영체제의 transport 계층에 부탁해 전달하게 되는데 이 때 전달되는 문, 경로가 **소켓**(**Socket**)이다. 반대로 받아오는 메시지도 소켓을 통해 들어오게 된다.

#### 주소
호스트의 IP 주소만을 가지고는 도착점 프로세스를 특정할 수 없기 때문에 *포트(port)* 번호를 같이 집어 넣어 식별한다. 예를 들어 HTTP 서버는 80, mail 서버는 25이다.

### 응용 프로그램은 어떤 특성을 요구할까?
각 응용 프로그램의 특성에 따라 다르다.
- Data integrity: 데이터의 무결성. 조작되지 않아야 함.
- Timing: 딜레이가 짧아야 함.
- Throughput: 미디어 스티리밍 같은 경우 단위 시간당 최소 프레임을 요하기 때문에 최소 throughput을 충족시켜야 함.
- Security: 보안

### 인터넷 전송 프로토콜 서비스

#### TCP
- 안전한 전송.
- 상대방과 연결을 해야함. 이것은 *hand-shaking* 과정을 거침.
- flow control: 보내는 프로세스(sender)가 **받는 프로세스**(**receiver**)에서 오버플로우가 일어나게 하지 않도록 조절.
- congestion control: **네트워크** 상에서 컨트롤하는 것으로 패킷 로스가 일어나지 않도록 한다.
- 위와 같은 제어를 하기 위해 OS가 버퍼를 할당함.

#### UDP
- 신뢰하지 못하는 전송.

공통적으로 두 전송 프로토콜 서비스 모두 **타이밍, 최소 쓰루풋 보장, 보안 기능은 지원하지 않는다.** 멀티미디어 어플리케이션이 많이 등장하면서 이 같은 기능들이 중요해졌지만 제대로 지원되지는 않아 연구가 계속되고 있다.

TCP가 UDP보다 훨씬 나은 것처럼 보인다. 그러나 다음과 같은 상황에서 UDP가 선호된다.

- TCP가 위와 같은 다양한 기능을 하기 위해서는 커넥션 셋업과 끝난 후 클린업 등 오버헤드가 따르는 작업을 수행해야 한다. 만약 한 번 메시지를 주고 받는 작업의 경우, 배보다 배꼽이 더 큰 상황이 벌어질 수도 있다.
- 역설적으로 어플리케이션 단에서 데이터의 무결성을 검사하는 일을 할 경우, TCP에서 한 번 더 검사할 필요를 못 느끼기 때문에 UDP를 사용한다.
- 미디어 스트리밍 같은 경우 일정 쓰루풋이 필요한 데 만약 네트워크 상에서 congestion이 일어날 수 있으면 TCP는 데이터의 전송을 막아 버린다. 그 결과 미디어의 스트리밍이 제대로 일어날 수 없게 된다.

### 어플리케이션 프로토콜

#### HTTP(Hypertext transfer protocol)
웹을 위해서 만들어진 프로토콜. 웹 페이지는 오브젝트들의 구성으로 이루어져 있는데 **URL**로 주소가 표현이 된다. 가장 보편적인 프로토콜 중의 하나이기 때문에 언제나 80번 포트를 사용한다.

클라이언트-서버 구조로 되어 있다.
- 클라이언트: 브라우저에 해당. 서버에 요청을 하고 받은 웹의 오브젝트들을 보여준다.
- 서버: 웹 서버 호스트에 존재하며 웹 브라우저가 요청한 것을 처리한다.

주로 TCP를 사용하는데, 그 이유는 주 사용 앱인 웹은 **데이터의 무결성**이 중요하기 때문이다. TCP 연결을 시작하자고 요청을 하면 핸드 쉐이킹이 이루어지고 연결이 된다. 이 때부터 클라이언트는 요청을 보내고 서버는 응답을 한다. 모든 작업이 완료되면 연결이 끊어지게 된다.

##### Stateless
서버는 클라이언트의 과거 요청들에 대한 정보를 유지하지 않는다.
> 상태를 유지하는 일은 복잡하다. 과거의 기록들(상태)를 유지 관리해야 하기 때문에 그에 따른 오버헤드가 발생하고 서버나 클라이언트 중 하나가 깨진 경우 상태가 서로 불일치하게 되어 동기화가 필요하다.

##### 두가지 종류: 비지속 연결과 지속 연결
- 비지속 연결
    - 요구/응답 쌍이 분리된 TCP 연결을 통해 송수신
    - 하나의 TCP 연결로 하나의 객체만 전송
    - 서버는 **응답을 한 후 바로 TCP 연결을 끊어버림**.
    - 다수의 객체를 받으려면 여러 번 TCP 연결을 시도해야 함.
    - 응답 시간: (2 RTT(Round-Trip Time) + 파일 전송 시간) * 오브젝트의 갯수
    - **병렬 TCP 연결**을 통해 동시에 오브젝트들을 가져오는 시도를 하기도 함.
- 지속 연결
    - 모든 요구/응답 쌍이 같은 TCP 연결 상에서 송수신
    - 다수의 객체들이 하나의 TCP 연결로 전송
    - 서버가 **응답을 보낸 후에도 TCP 연결을 유지**. 이 연결을 통해 이후의 메시지들도 송수신함.
    - 모든 참조 객체들에 대해 1 RTT만 필요.

##### HTTP 요청 메시지
아스키 코드로 구성되어 있음.

구성은 **request line + header lines + body**

![](images/httpRequestFormat.png)

검색어 입력 같은 폼 입력을 받을 때는 다음과 같은 메서드를 사용한다.
- POST 방식: *entity body*에 입력한 내용을 실어서 보내게 된다.
- URL 방식: GET 방식을 그대로 쓰면서 URL 필드로 서버에 업로드 한다.

##### HTTP 응답 메시지
![](images/httpResponseMessage.png)

응답 상태 코드에는 다음과 같은 것들이 있다.
- 200: OK
- 301: Moved Permanently
- 400: Bad Request
- 404: Not Found
- 505: HTTP Version Not Supported

##### 쿠키(Cookie)
HTTP가 stateless한 특성을 가지고 있기 때문에 **사용자 상태**를 추적하고 유지하도록 쿠키를 사용한다.

처음 연결이 되면 서버는 사용자의 고유 식별자(unique id)를 내어주게 되고 클라이언트는 이것을 쿠키에 저장하게 된다. 다음 연결 시에 이 고유 식별자를 포함하는 연결을 하게 되고 서버는 이것을 통해 과거의 기록을 볼 수 있다.
