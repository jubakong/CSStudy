# CPU 스케줄링

## CPU 버스트와 I/O 버스트

프로세스의 실행은 CPU 실행과 입출력 대기로 구성된다. 프로세스는 이 두 상태를 교대로 왔다갔다 한다.

* CPU 버스트: 프로세스 실행이 시작, CPU가 연산을 수행
* I/O 버스트: 입출력을 기다림

## 선점과 비선점

CPU 스케줄링은 프로세스의 상태에 따라 다음 네 가지 상황에서 발생할 수 있다.

1. 실행 상태 -> 준비완료 상태
2. 대기 상태 -> 준비완료 상태
3. 실행 상태 -> 대기 상태
4. 프로세스 종료

### 비선점

상황 3과 4의 경우에 스케줄러는 선택의 여지가 없다. 실행을 위해 새로운 프로세스를 반드시 선택하여야 한다. 이런 상황에서 발생하는 스케줄링을 비선점(non-preemptive) 또는 협조적(cooperative) 스케줄링이라고 한다.

비선점 스케줄링은 다중 프로그래밍에서의 기본 스케줄링이다. CPU가 한 프로세스에 할당되면 프로세스가 대기 상태로 전환되거나 종료되어 CPU를 방출할 때까지 CPU를 점유한다. 즉 운영체제가 강제로 CPU 사용을 해제하지 못한다.

*용어가 조금 어려운데 운영체제의 입장에서 표현한 용어라고 생각하자.  
비선점이란 우선권이 없음을 뜻한다. 비선점 스케줄링에서 운영체제는 CPU에 대한 우선권이 없고 협조적이어야 한다.*

### 선점

상황 1과 2의 경우에는 선택의 여지가 있다. 운영체제는 현재 CPU를 사용하고 있는 프로세스의 수행을 정지할 수 있다.

## 스케줄링 기준

CPU 이용률과 처리량을 최대화하고 총처리, 대기, 응답 시간을 최소화하는 것이 바람직한 스케줄링이다.

* CPU 이용률: 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
* 처리량: CPU가 단위 시간 당 처리하는 프로세스의 개수
* 총처리 시간: 프로세스가 시작해서 끝날 때까지 걸리는 시간
* 대기 시간: 프로세스가 준비완료 큐 내에서 대기하는 시간의 총합
* 응답 시간: 대화식 시스템(Interactive System)에서 요청 후 첫 응답이 올 때까지의 시간


## 스케줄링 알고리즘

### FCFS

* 선입 선처리 (First Come, First Served) 스케줄링
* CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
* FIFO 큐를 사용하여 간단하게 구현 가능
* 비선점형 스케줄링

#### 한계: 호위 효과 (Convoy Effect)

버스트 시간이 긴 하나의 프로세스가 CPU를 양도할 때까지 다른 모든 프로세스들이 기다리는 현상이다.

프로세스 P1의 버스트 시간이 24ms, P2는 3ms, P3은 3ms이라고 하자. 프로세스들이 큐에 도착하는 순서에 따른 두 가지 시나리오가 있다.
* 시나리오 A
  * P1 - P2 - P3
  * 평균 대기 시간: (0 + 24 + 27) / 3 = 17ms
* 시나리오 B
  * P2 - P3 - P1
  * 평균 대기 시간: (0 + 3 + 6) / 3 = 3ms

두 시나리오의 평균 대기 시간 차이가 크다. 이처럼 FCFS 스케줄링은 평균 대기 시간이 매우 길어질 수 있다는 단점이 있다. 특히 시분할 시스템에서 문제가 되는데, 시분할 시스템에서는 각 사용자가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.

### SJF

* 최단 작업 우선 (Shortest Job First) 스케줄링
* 다음 CPU 버스트 시간이 가장 짧은 프로세스에 CPU를 먼저 할당
* 최소의 평균 대기 시간 달성 가능
* CPU 버스트 시간이 동일하다면 FCFS를 따름

#### 비선점형 SJF

현재 준비완료 큐에 4개의 프로세스가 존재하는데, 프로세스 P1의 버스트 시간이 8ms, P2는 4ms, P3은 9ms, P4는 5ms이라고 하자.

SJF를 따르면 순서는 P2 - P4 - P1 - P3가 된다. 평균 대기 시간은  7.75ms.

#### SRTF (선점형 SJF)

최소 잔여시간 우선(Shortest Remaining Time First) 스케줄링이라고도 한다. 이전의 프로세스 P0가 실행되는 동안 새로운 프로세스 P1이 준비완료 큐에 도착하였다고 하자. 선점형 SJF를 따르면 P0의 잔여 버스트 시간과 P1의 버스트 시간 중에 더 짧은 것이 CPU를 점유하게 된다.

비선점형 SJF와 상황에 덧붙여 도착 시간이 각각 P1 0, P2 1, P3 2, P3 3이라고 하자. 1ms 차이를 두고 순서대로 도착하였으나 스케줄링 결과는 다음과 같다. 평균 대기 시간 6.5ms.

P1(0-1) P2(1-5) P4(5-10) P1(10-17) P3(17-26)

새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어지는 것이다. 따라서 다음 CPU 버스트 시간을 측정하는 것이 매우 어렵다는 단점이 있다.


### 우선순위 (Priority)

* 미리 주어진 우선순위에 따라 CPU를 할당
* SJF도 우선순위 스케줄링의 일종이다.
* 선점형과 비선점형이 있다.

#### 한계: 기아 상태 (Starvation)

낮은 우선순위를 가진 프로세스는 영원히 수행되지 않을 수 있다. 우선순위 스케줄링에서 낮은 우선순위를 가진 프로세스의 결말은 두 가지가 있다.

* 자기 차례가 되어 수행된다.
* 시스템이 크래시하여 결국 프로세스를 잃어버리게 된다.

#### 해결법: 노화 (Aging)

기다리는 시간에 따라 우선순위를 증가시켜주는 방법이다. 오래 기다린만큼 우선순위를 높여주어 결국에는 실행될 수 있도록 하는 것이다.


### 라운드 로빈 (Round Robin)

* 시간 할당량(time quantum)만큼 수행을 한 프로세스는 큐의 마지막으로 들어가 재할당을 기다림
* 시간 할당량은 보통 10 ~ 100ms
* 준비완료 큐는 원형 큐
* 선점형

매우 공평한 스케줄링 알고리즘이다. 라운드 로빈에서 중요한 것은 시간 할당량(q)을 어느정도로 설정하는가이다. 라운드 로빈은 FCFS에 기반을 두고 있기에 q가 너무 크면 FCFS와 다를 게 없어진다. 반면 q가 작아질수록 응답 시간이 줄어들어 사용자에게 빠른 응답을 제공할 수 있지만, 문맥 교환이 자주 발생하여 효율이 떨어진다.

FCFS의 예와 같이 프로세스 P1의 버스트 시간이 24ms, P2는 3ms, P3은 3ms이라고 하자. 시간 할당량은 4ms이다. 라운드 로빈에서의 스케줄링은 다음과 같다. 평균 대기시간은 5.66ms이다.

P1(0-4) P2(4-7) P3(7-10) P1(10-14) P1(14-18) P1(18-22) P1(22-26) P1(26-30)

### Multi-level Queue

* 준비완료 큐를 여러 개의 큐로 분리하여 각각에 대해 다른 스케줄링 알고리즘을 사용하는 기법
* 각 큐에 CPU를 어떻게 할당할 것인지를 결정해야 함. 큐에 대한 Priority 또는 Time slice를 사용할 수 있음.

#### Foreground 큐

Interactive한 동작이 필요한 프로세스를 위한 큐.
Round Robin 기법 사용.

#### Background 큐

CPU 연산 작업을 주로 수행하는 프로세스를 위한 큐.
FCFS 기법 사용.

### Multi-level Feedback Queue

---

#### References
* 공룡책
* http://asfirstalways.tistory.com/124
