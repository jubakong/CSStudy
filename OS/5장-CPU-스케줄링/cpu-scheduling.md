# CPU 스케줄링

## CPU 버스트와 I/O 버스트

프로세스의 실행은 CPU 실행과 입출력 대기로 구성된다. 프로세스는 이 두 상태를 교대로 왔다갔다 한다.

* CPU 버스트: 프로세스 실행이 시작, CPU가 연산을 수행
* I/O 버스트: 입출력을 기다림

## 선점과 비선점

CPU 스케줄링은 프로세스의 상태에 따라 다음 네 가지 상황에서 발생할 수 있다.

1. 실행 상태 -> 준비완료 상태
2. 대기 상태 -> 준비완료 상태
3. 실행 상태 -> 대기 상태
4. 프로세스 종료

### 비선점

상황 3과 4의 경우에 스케줄러는 선택의 여지가 없다. 실행을 위해 새로운 프로세스를 반드시 선택하여야 한다. 이런 상황에서 발생하는 스케줄링을 비선점(non-preemptive) 또는 협조적(cooperative) 스케줄링이라고 한다.

비선점 스케줄링은 다중 프로그래밍에서의 기본 스케줄링이다. CPU가 한 프로세스에 할당되면 프로세스가 대기 상태로 전환되거나 종료되어 CPU를 방출할 때까지 CPU를 점유한다. 즉 운영체제가 강제로 CPU 사용을 해제하지 못한다.

### 선점

상황 1과 2의 경우에는 선택의 여지가 있다. 운영체제는 현재 CPU를 사용하고 있는 프로세스의 수행을 정지할 수 있다.

## 스케줄링 기준

CPU 이용률과 처리량을 최대화하고 총처리, 대기, 응답 시간을 최소화하는 것이 바람직한 스케줄링이다.

* CPU 이용률: 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
* 처리량: CPU가 단위 시간 당 처리하는 프로세스의 개수
* 총처리 시간: 프로세스가 시작해서 끝날 때까지 걸리는 시간
* 대기 시간: 프로세스가 준비완료 큐 내에서 대기하는 시간의 총합
* 응답 시간: 대화식 시스템(Interactive System)에서 요청 후 첫 응답이 올 때까지의 시간


## 스케줄링 알고리즘

### 1. FCFS

* 선입 선처리 (First Come, First Served) 스케줄링
* CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
* FIFO 큐를 사용하여 간단하게 구현 가능
* 비선점형 스케줄링

#### 한계: 호위 효과 (Convoy Effect)

버스트 시간이 긴 하나의 프로세스가 CPU를 양도할 때까지 다른 모든 프로세스들이 기다리는 현상이다.

프로세스 P1의 버스트 시간이 24ms, P2는 3ms, P3은 3ms이라고 하자. 프로세스들이 큐에 도착하는 순서에 따른 두 가지 시나리오가 있다.
* 시나리오 A
  * P1 - P2 - P3
  * 평균 대기 시간: (0 + 24 + 27) / 3 = 17ms
* 시나리오 B
  * P2 - P3 - P1
  * 평균 대기 시간: (0 + 3 + 6) / 3 = 3ms

두 시나리오의 평균 대기 시간 차이가 크다. 이처럼 FCFS 스케줄링은 평균 대기 시간이 매우 길어질 수 있다는 단점이 있다. 특히 시분할 시스템에서 문제가 되는데, 시분할 시스템에서는 각 사용자가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.

### 2. SJF

* 최단 작업 우선 (Shortest Job First) 스케줄링
* 다음 CPU 버스트 시간이 가장 짧은 프로세스에 CPU를 먼저 할당
* 최소의 평균 대기 시간 달성 가능
* CPU 버스트 시간이 동일하다면 FCFS를 따름

#### 비선점형 SJF

현재 준비완료 큐에 4개의 프로세스가 존재하는데, 프로세스 P1의 버스트 시간이 8ms, P2는 4ms, P3은 9ms, P4는 5ms이라고 하자.

SJF를 따르면 순서는 P2 - P4 - P1 - P3가 된다. 평균 대기 시간은 7.75ms.

#### SRTF (선점형 SJF)

최소 잔여시간 우선(Shortest Remaining Time First) 스케줄링이라고도 한다. 이전의 프로세스 P0가 실행되는 동안 새로운 프로세스 P1이 준비완료 큐에 도착하였다고 하자. 선점형 SJF를 따르면 P0의 잔여 버스트 시간과 P1의 버스트 시간 중에 더 짧은 것이 CPU를 점유하게 된다.

비선점형 SJF와 상황에 덧붙여 도착 시간이 각각 P1 0, P2 1, P3 2, P3 3이라고 하자. 1ms 차이를 두고 순서대로 도착하였으나 스케줄링 결과는 다음과 같다. 평균 대기 시간 6.5ms.

P1(0-1) P2(1-5) P4(5-10) P1(10-17) P3(17-26)

새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어지는 것이다. 따라서 다음 CPU 버스트 시간을 측정하는 것이 매우 어렵다는 단점이 있다.


### 3. 우선순위 (Priority) 스케줄링

* 미리 주어진 우선순위에 따라 CPU를 할당
* SJF도 우선순위 스케줄링의 일종이다.
* 선점형과 비선점형이 있다.

#### 한계: 기아 상태 (Starvation)

낮은 우선순위를 가진 프로세스는 영원히 수행되지 않을 수 있다. 우선순위 스케줄링에서 낮은 우선순위를 가진 프로세스의 결말은 두 가지가 있다.

* 자기 차례가 되어 수행된다.
* 시스템이 크래시하여 결국 프로세스를 잃어버리게 된다.

#### 해결법: 노화 (Aging)

기다리는 시간에 따라 우선순위를 증가시켜주는 방법이다. 오래 기다린만큼 우선순위를 높여주어 결국에는 실행될 수 있도록 하는 것이다.


### 4. 라운드 로빈 (Round Robin)

* 시간 할당량(time quantum)만큼 수행을 한 프로세스는 큐의 마지막으로 들어가 재할당을 기다림
* 시간 할당량은 보통 10 ~ 100ms
* 준비완료 큐는 원형 큐
* 선점형

매우 공평한 스케줄링 알고리즘이다. 라운드 로빈에서 중요한 것은 시간 할당량(q)을 어느정도로 설정하는가이다. 라운드 로빈은 FCFS에 기반을 두고 있기에 q가 너무 크면 FCFS와 다를 게 없어진다. 반면 q가 작아질수록 응답 시간이 줄어들어 사용자에게 빠른 응답을 제공할 수 있지만, 문맥 교환이 자주 발생하여 효율이 떨어진다.

FCFS의 예와 같이 프로세스 P1의 버스트 시간이 24ms, P2는 3ms, P3은 3ms이라고 하자. 시간 할당량은 4ms이다. 라운드 로빈에서의 스케줄링은 다음과 같다. 평균 대기시간은 5.66ms이다.

P1(0-4) P2(4-7) P3(7-10) P1(10-14) P1(14-18) P1(18-22) P1(22-26) P1(26-30)

### 5. 다단계 큐 (Multi-level Queue)

* 준비완료 큐를 여러 개의 큐로 분류하여 각 큐가 각기 다른 스케줄링 알고리즘을 가지게 하는 기법
* 메모리 크기, 우선순위, 유형 등 프로세스의 특성에 따라 하나의 큐에 영구적으로 할당됨
* 큐와 큐 사이에 스케줄링도 반드시 필요. 우선순위(priority) 또는 시분할(time slice)로 가능.

#### 우선순위 방식

일반적으로 고정 우선순위의 선점형 스케줄링으로 구현되어 각 큐는 자기보다 낮은 우선순위를 가진 큐보다 절대적인 우선순위를 가진다. 예를 들어 다음의 두 가지 큐가 있다고 하자.

* 우선순위가 높은 foreground 큐
  * 대화형 프로세스를 위한 큐
  * Round Robin
* 우선순위가 낮은 background 큐
  * 연산 작업을 주로 수행하는 일괄처리 프로세스를 위한 큐
  * FCFS

Foreground 큐가 background 큐보다 절대적으로 높은 우선순위를 가진다. 따라서 foreground 큐가 비어있지 않다면 background 큐에 있는 프로세스는 실행될 수 없다. 또 background에 있는 프로세스가 실행되는 중이라 하더라도 foreground 큐에 프로세스가 새로 들어간다면 background는 선점된다.

#### 시분할 방식

큐들 사이에 시간을 나누어 사용하는 방법이다. 각 큐는 CPU 시간의 일정부분을 받아서 자기 큐에 있는 프로세스들을 스케줄링한다. 예를 들어 아래와 같이 스케줄링하는 것이다.

* foreground 큐
  * 80% 할당받음
  * Round Robin
* background 큐
  * 20% 할당받음
  * FCFS

### 6. 다단계 피드백 큐 (Multi-level Feedback Queue)

기존의 다단계 큐 스케줄링에서는 프로세스의 특성이 바뀌지 않는다고 보아 프로세스가 큐 사이를 이동하는 것을 허용하지 않았다. 스케줄링 오버헤드는 적다는 장점이 있지만 융통성이 부족하다는 단점이 있다.

이 문제를 극복하기 위해 나온 것이 다단계 피드백 큐 스케줄링이다. 프로세스가 큐 사이를 이동하는 것이 허용된다. 큐를 구분하는 기준은 CPU 버스트이다. 이 방법에서는 입출력 중심의 프로세스와 대화형 프로세스를 높은 우선순위의 큐에 넣는다. 반대로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스들은 높은 곳으로 이동(노화)하여 기아 상태를 예방한다. 다음의 큐 3개를 가정하자.

* 큐 0: RR, quantum 8ms
* 큐 1: RR, quantum 16ms
* 큐 2: FCFS

CPU 버스트가 8ms 이하인 프로세스는 최고의 우선순위로 실행될 것이다. 8ms~24ms 인 프로세스는 그 다음의 우선순위를 받게 될 것이다. 그리고 CPU 버스트가 너무 긴 프로세스는 큐 2로 가게 될 것이다.

다단계 큐와 비교하였을 때 단점은, 프로세스를 다른 큐로 올려주거나 내리는 시기를 결정하는 등 큐 간 이동가능성 때문에 고려해야할 것이 많아 설계하기 복잡하다는 것이다.

---

#### References
* Operating System Concepts (8th Edition), Abraham Silberschatz, 홍릉과학출판사.
