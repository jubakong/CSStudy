# 프로세스 동기화 Part 1

## 경쟁 상황 (Race Condition)

경쟁 상황이란 **동시에 여러 개의 프로세스가 동일한 자료에 접근하여 조작하고, 그 실행결과가 접근이 발생한 특정 순서에 의존하는 상황** 을 말한다. 운영체제는 여러 부분에서 자원을 조작하기 때문에 경쟁 상황은 빈번하게 발생할 수 밖에 없다. 특히나 다중코어 시스템과 다중 스레드 프로그래밍의 환경에서는 여러 스레드들이 자원을 공유할 가능성이 매우 높다.

이 문제를 해결하려면 한 순간에 하나의 프로세스만 공유하는 데이터를 조작하도록 보장해야 한다. 즉 프로세스들을 동기화할 필요가 있다.

## 임계 영역 (Critical Section)

각 프로세스는 임계 영역이라는 코드 부분을 포함하고 있고, 이 안에서 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 변경하거나 파일을 쓰거나 하는 등의 작업을 수행한다. 이 때 중요한 사실은 **한 프로세스가 자신의 임계 영역에서 작업을 수행하는 동안에는 다른 프로세스가 이 영역에 들어갈 수 없다** 는 것이다.

임계 영역 문제를 해결하기 위한 해결안은 다음 세 가지 조건을 충족해야 한다.
1. 상호 배제 (mutual exclusion)  
  한 프로세스가 자기 임계 영역에서 실행된다면 다른 프로세스들은 그 임계 영역에서 실행될 수 없다.
2. 진행 (progress)  
  임계 영역에서 실행 중인 프로세스가 없고 진입하려는 프로세스들이 있다면, 이들 중에 진입시킬 프로세스를 선택하여 진입시켜야 한다. 이 선택은 무기한으로 연기되어서는 안된다.
3. 한정된 대기 (bounded waiting)  
  프로세스가 임계 영역에 진입하려는 요청을 한 뒤로 요청이 허용될 때까지 다른 프로세스들이 임계 영역에 진입하도록 허용하는 횟수에는 제한이 있어야 한다. 즉 어떤 프로세스가 기아 상태가 되는 것을 막아야 한다.

프로세스들이 협력적으로 실행되도록 하기 위하여 프로세스들은 일반적으로 다음과 같은 구조로 설계된다.

```java
do {
  진입 영역 (entry section) // 임계 영역으로의 진입 허가를 요청하는 코드
  임계 영역
  퇴출 영역 (exit section) // 임계 영역에서 작업을 마친 후 마무리 하는 코드
  나머지 영역 (remainder section) // 코드의 나머지 부분
} while (TRUE);
```


## 소프트웨어적 해결: 피터슨의 해결안 (Peterson's solution)

현대 컴퓨터 구조에서 피터슨의 해결안이 항상 올바르게 동작한다는 보장은 없다. 현대 컴퓨터 구조는 load와 store 같은 기본적인 기계어를 실행하는 방식을 따르고 있기 때문이다. 그럼에도 피터슨의 해결안은 임계 영역을 해결하기 위한 좋은 시도로서 알고리즘적 설명을 제시하고, 앞서 언급한 세 가지 요구 조건에 대하여 생각해 볼 수 있는 기회를 제공한다.

두 개의 프로세스 Pi, Pj가 있다고 가정한다.  
turn은 임계 영역으로 진입할 순번을 나타낸다. 즉 자기 turn인 경우에만 임계 영역에 들어갈 수 있다. flag 배열은 임계 영역으로 진입할 준비가 되었다는 것을 나타낸다.

```c
do {
  flag[i] = TRUE; // Pi가 깃발을 들어 임계 영역에 들어가고 싶다는 의사를 밝힌다.
  turn = j; // 차례를 Pj에게 넘긴다.
  while (flag[j] && turn == j); // Pj가 깃발을 들고 있고 Pj의 차례라면 기다린다. 다시 말해 Pj가 깃발을 내렸거나 Pj 차례가 아니라면 Pi가 들어간다.

  // 임계 영역

  flag[i] = FALSE; // 나오면서 깃발을 내려 Pj가 들어갈 수 있도록 한다.

  // 나머지 영역
} while (TRUE);
```

turn만 이용한 방식의 문제점은 과잉양보이다. 반드시 번갈아 들어가야한다는 제약 때문에 특정 프로세스가 더 빈번히 들어가고자 하더라도 그렇지 못한다는 것이다. 그리고 flag만 이용하는 방식은 둘 다 깃발을 들고 무한히 기다리는 상황이 발생할 수 있다는 점이다. 피터슨의 해결안은 이 두 가지 도구를 합하여, 깃발을 들고 있는 프로세스에 한정하여 차례를 주고 받을 수 있도록 하여 모든 조건을 만족시킬 수 있었다.

### 한계

이 해결안에는 busy waiting(또는 spin lock)으로 인한 자원 사용의 비효율 문제가 있다. 프로세스가 while 문에 걸려 계속 돌고 있는 동안에도 CPU 자원을 의미 없이 소모하고 있다는 것이다. 또한 확장 가능성에도 문제가 있다. 3개 이상의 프로세스가 존재하는 상황에서의 알고리즘을 구현하는 것과 이를 증명하는 것이 매우 복잡하다. 이러한 문제들은 하드웨어적인 접근을 통해 간단하게 해결할 수 있다.

## 하드웨어적 해결: 동기화 하드웨어

락(lock)이라는 간단한 도구를 통해 하드웨어적으로 임계 영역 문제를 해결할 수 있다. 임계 영역은 락에 의해 보호된다. 프로세스는 임계 영역에 진입하기 전에 반드시 락을 획득하고, 나올 때에는 락을 방출한다.

하드웨어적인 해결 방법에서는 동기화 변수인 `lock`이라는 변수를 둔다. 이 변수는 `false`로 초기화된다.

```c
boolean lock = false;
```

피터슨의 해결안과 다른 점은 작업이 하드웨어적으로 atomic하게 수행된다는 것이다. 즉 아래의 TestAndSet 메서드가 호출되었을 때, 작업이 수행되는 동안 CPU를 선점 당하지 않아 작업이 쪼개지지 않고 한 덩어리 째로 끝까지 수행되는 것이 보장된다는 뜻이다. 따라서 TestAndSet이 호출되면 변수 `lock`을 read하는 것과 true로 set하는 동작이 중간에 선점 당하지 않고 한번에 수행된다.

```c
Boolean TestAndSet(boolean *target) {
  boolean rv = *target; // read
  * target = true; // set
  return rv;
}

do {
  while (TestAndSet(&lock)); // 락 획득

  // 임계 영역

  lock = FALSE; // 락 방출

  // 나머지 영역
} while (TRUE);
```

## 세마포어 (semaphore)

세마포어는 락의 추상 자료형(ADT)이다. 하드웨어적 해결안을 프로그래머가 직접 만들어 사용하기에는 다소 복잡하기 때문에 이를 극복하기 위해 세마포어라는 추상화된 동기화 도구를 이용하는 것이다.

세마포어를 정수 변수 `S`라고 하자. 이 변수는 두 개의 연산 `P(S)`와 `V(S)`로만 접근이 가능하다. P 연산은 공유 데이터를 획득하는 진입 영역, V 연산은 공유 데이터를 반납하는 퇴출 영역에 해당한다. 이 연산들은 반드시 독립적이고 원자적으로 수행되어야한다.

```c
P(S) {
  while (S <= 0);
  S--;
}

V(S) {
  S++;
}
```

### 세마포어의 종류

#### 카운팅 세마포어 (Counting Semaphore)

* S는 현재 사용 가능한 자원의 개수
* S는 가용한 자원의 개수로 초기화됨
* S의 범위는 한정되어 있지 않음

#### 이진 세마포어 (Binary Semaphore, mutex)

* S는 0 또는 1, 초기값은 1.
* 시스템에서 상호 배제를 제공하기 때문에 mutex 락이라고도 불림
* 카운팅 세마포어보다 구현이 간단

### block & wakeup 방식의 구현

세마포어는 여전히 busy-waiting 문제를 가지고 있다. 예를 들어 이진 세마포어의 경우 S가 0일 때 어떤 프로세스는 P 연산 내부의 while 문을 돌면서 다른 프로세스가 V 연산을 해줄 때까지 기다리며 CPU를 낭비하고 있게 된다.

block & wakeup 방식의 세마포어 구현을 통해 이 문제를 해결할 수 있다. sleep lock이라고도 한다. 세마포어는 다음과 같은 구조체로 정의된다. value는 가용 자원의 개수이고 list는 sleep 상태의 프로세스가 담겨있는 큐이다.

```c
typedef struct {
  int value;
  struct process *list;
} semaphore;
```

P와 V 연산에도 변경이 있다. P 연산이 호출되고 가용할 자원이 남아있지 않다면 이 프로세스를 대기 큐에 추가하고 프로세스의 상태를 대기 상태로 전환시킨다. 이후 control이 CPU 스케줄러에게 넘어가고 스케줄러는 다른 프로세스를 선택하여 실행시킨다.

P 연산을 통해 봉쇄되어 있는 프로세스는 여유 자원이 생겼을 때 V 연산을 통해 다시 시작될 수있다. 대기 큐에서 프로세스를 꺼내와서 깨우면 대기 상태였던 프로세스는 준비완료 큐로 넘어가게 된다.

```c
void P(semaphore *S) {
  S->value--; // 임계 영역에 들어갈 준비가 되었고 자원을 필요로 한다는 표시
  if (S->value < 0) {
    // 이 프로세스를 S->list에 추가
    block();
  }
}

void V(semaphore *S) {
  S->value++; // 작업이 끝나 자원을 반납할테니 다른 프로세스가 가져다쓰라는 표시
  if (S->value <= 0) {
    // S->list로부터 프로세스 P 하나 꺼냄
    wakeup(P);
  }
}
```

기존의 세마포어 S와 새로운 방식의 세마포어 S.value는 의미하는 바가 다르다. 카운팅 세마포어 방식에서 변수 S는 실제 가용한 자원의 개수를 나타냈지만, block & wakeup 방식에서의 S.value는 지금 자원을 사용할 수 있느냐 없느냐의 의미가 더 크다. 즉 value가 양수이면 사용할 자원이 있으므로 `block()` 또는 `wakeup(P)`할 필요가 없다. 하지만 value가 음수라면 자원을 기다리는 문제 때문에 sleep 큐를 통한 중재가 필요할 것이다.

## 교착상태(Deadlock)와 기아(Starvation)

세마포어는 교착상태가 발생할 수 있다는 한계를 가지고 있다. 교착상태란 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 이벤트를 무한히 기다리는 현상을 말한다. 각각 1로 초기화된 S와 Q라는 세마포어와 이것을 사용하는 두 개의 프로세스 P0, P1이 있다고 하자.

```
P0 : P(S) - P(Q) ... V(S) - V(Q)
P1 : P(Q) - P(S) ... V(Q) - V(S)
```

이와 같은 상황에서 먼저 P1가 P(Q)를 실행했다고 가정하자. P0가 P(Q)를 실행할 때 P0는 P1이 V(Q)를 실행할 때까지 기다려야 한다. 마찬가지로 P1가 P(S)를 실행할 때는 P0이 V(S)를 실행할 때까지 기다려야 한다. 서로 기다리고 있는 V 연산은 실행될 수 없고 이 때 두 프로세스는 교착상태에 있다고 한다.

교착상태의 빠진 프로세스는 기아 또는 무기한 봉쇄(indefinite blocking) 문제에 봉착하여, 세마포어에서 기약 없이 대기하게 된다. 교착상태는 여러 프로세스의 관점에서의 용어이고 기아는 각각의 프로세스의 관점에서의 용어이다.

----

#### References
* Operating System Concepts (8th Edition), Abraham Silberschatz, 홍릉과학출판사
* [[강의] 운영체제, 반효경, 이화여자대학교, 2017 - KOCW](http://www.kocw.net/home/search/kemView.do?kemId=1226304)
